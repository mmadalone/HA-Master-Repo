blueprint:
  name: Music Assistant – Follow me (multi-room advanced)
  description: |
    Follow your Music Assistant queue between areas based on presence.

    Features:
      - Presence-driven follow-me between multiple zones.
      - Priority by order of presence sensors / players (first = highest).
      - Optional persons gate (run only when selected persons are home).
      - Optional pre- and post-transfer announcement scripts.
      - Optional allowed source players (only follow sessions from these players).
      - Optional priority anchor:
        - If music is already in a higher-priority area that still has presence,
          it will not auto-move "down" into a lower-priority area.
      - Optional anti-flicker:
        - Minimum time a presence sensor must be ON before it triggers follow.
      - Optional global cooldown:
        - After a successful transfer, ignore new follow attempts for a number
          of seconds.
      - Optional "only follow when playing":
        - If enabled, follow-me only runs when at least one configured player
          is actually playing.
      - Optional "protect target playback":
        - If enabled, the automation will not move the queue into a player
          that is already actively playing something.
      - Optional TTS filter:
        - Ignore short media (e.g. TTS clips) when deciding if music is
          "playing", based on minimum duration.

  domain: automation

  input:
    follow_switch:
      name: Follow music toggle
      description: >
        Global on/off switch for this follow-me logic.
      selector:
        entity:
          domain: input_boolean

    presence_sensors:
      name: Presence sensors (priority order, first = highest)
      description: >
        Binary sensors that indicate someone is in a zone.
        The order here defines the zone priority (0 = highest).
      selector:
        entity:
          domain: binary_sensor
          multiple: true

    target_players:
      name: Music Assistant players (same order as sensors)
      description: >
        Music Assistant media_player entities, in the exact same order
        as the presence sensors above.
      selector:
        entity:
          domain: media_player
          multiple: true

    person_required:
      name: Require persons to be home
      description: >
        If enabled, the automation only runs when at least one of the selected
        persons below is home.
      default: false
      selector:
        boolean: {}

    persons:
      name: Persons (optional)
      description: >
        Optional persons that must be home when "Require persons" is enabled.
        If left empty and "Require persons" is ON, the person condition will
        always fail (no follow).
      default: []
      selector:
        entity:
          domain: person
          multiple: true

    allowed_source_players:
      name: Allowed source players (optional)
      description: >
        Optional allow-list of players that may act as SOURCE for follow-me.
        When this list is empty, any player in the configured target list may
        be used as a source. When not empty, follow-me will only move queues
        that currently live on one of these players.
      default: []
      selector:
        entity:
          domain: media_player
          multiple: true

    only_follow_when_playing:
      name: Only follow when music is playing
      description: >
        If enabled, follow-me only runs when at least one of the configured
        players is actually in the "playing" state. If everything is paused or
        idle (or only short TTS is playing), no transfer happens and no
        announcements are made.
      default: true
      selector:
        boolean: {}

    min_music_duration_seconds:
      name: Minimum media duration to treat as music
      description: >
        When deciding if "music is playing", ignore playback shorter than this
        many seconds (useful to ignore short TTS clips). Streams or unknown
        duration (0) are always treated as music.
      default: 20
      selector:
        number:
          min: 0
          max: 600
          unit_of_measurement: s
          mode: slider

    protect_target_playback:
      name: Skip transfer if target is already playing
      description: >
        If enabled, the automation skips follow-me when the target player is
        already actively playing something (playing/buffering). This prevents
        hijacking an existing session in the room you move into.
      default: true
      selector:
        boolean: {}

    enforce_priority_anchor:
      name: Enforce priority anchor
      description: >
        If enabled, music will not be moved from a higher-priority zone to a
        lower-priority zone while the higher-priority zone still has presence.
        Moving from low → high is always allowed.
      default: false
      selector:
        boolean: {}

    min_presence_on_time:
      name: Minimum zone presence time before follow
      description: >
        Minimum duration a presence sensor must stay ON before it can trigger
        follow-me. Set to 0 to trigger immediately when the sensor turns ON.
      default:
        seconds: 0
      selector:
        duration: {}

    delay_seconds:
      name: Delay before transfer (seconds)
      description: >
        Optional delay between the pre-transfer announcement (if any) and
        transferring the queue. Set to 0 for immediate transfer after the
        pre-announcement.
      default: 0
      selector:
        number:
          min: 0
          max: 600
          unit_of_measurement: s
          mode: slider

    cooldown_seconds:
      name: Global cooldown after successful transfer (seconds)
      description: >
        Minimum time between successful queue transfers. Requires the helper
        below. Set to 0 to disable cooldown.
      default: 0
      selector:
        number:
          min: 0
          max: 3600
          unit_of_measurement: s
          mode: slider

    cooldown_helper:
      name: Cooldown helper (input_datetime, optional)
      description: >
        Input_datetime entity used to remember the time of the last successful
        queue transfer. It must have both date and time. If omitted or if
        cooldown_seconds is 0, the cooldown check is skipped.
      default:
      selector:
        entity:
          domain: input_datetime
          multiple: false

    # Pre-transfer announcement
    pre_announcements_enabled:
      name: Run pre-transfer announcement script
      description: >
        If enabled, the automation will call the selected script BEFORE
        moving the queue, passing "target_player" and "source_player" as
        variables. The script can e.g. speak on the target player before
        the music starts there.
      default: false
      selector:
        boolean: {}

    pre_announcement_script:
      name: Pre-transfer announcement script (optional)
      description: >
        Script to call before a successful queue transfer. It will receive
        variables "target_player" and "source_player".
        Example: script.announce_music_follow_me_tts_llm_driven
      default:
      selector:
        entity:
          domain: script
          multiple: false

    # Post-transfer announcement
    announcements_enabled:
      name: Run post-transfer announcement script
      description: >
        If enabled, the automation will call the selected script AFTER
        moving the queue, passing "target_player" and "source_player"
        as variables.
      default: true
      selector:
        boolean: {}

    announcement_script:
      name: Post-transfer announcement script (optional)
      description: >
        Script to call after a successful queue transfer. It will receive
        variables "target_player" and "source_player".
        Example: script.announce_music_follow_me_tts_llm_driven
      default:
      selector:
        entity:
          domain: script
          multiple: false

    treat_unknown_duration_as_music:
      name: Treat unknown duration as music
      description: >
        If enabled, players with media_duration 0 are treated as music sessions
        (good for radio streams but may also count TTS as music). If disabled,
        media_duration 0 will be ignored for "music playing" checks.
      default: true
      selector:
        boolean: {}

    voice_assistant_guard:
      name: Block while voice assistant is active (optional)
      description: >
        Optional helper (for example input_boolean.voice_pe_ducking_active)
        that is turned ON while your voice assistant / TTS is speaking.
        When this is ON, follow-me does nothing.
      default:
      selector:
        entity:
          multiple: false

mode: restart
max_exceeded: silent

variables:
  presence_list: !input presence_sensors
  player_list: !input target_players
  follow_switch_entity: !input follow_switch
  person_list: !input persons
  require_person: !input person_required
  allowed_source_players_list: !input allowed_source_players
  enforce_priority_anchor_flag: !input enforce_priority_anchor
  delay_seconds_value: !input delay_seconds

  cooldown_seconds_value: !input cooldown_seconds
  cooldown_helper_entity: !input cooldown_helper

  pre_announcements_enabled_flag: !input pre_announcements_enabled
  pre_announcement_script_entity: !input pre_announcement_script

  announcements_enabled_flag: !input announcements_enabled
  announcement_script_entity: !input announcement_script

  only_follow_when_playing_flag: !input only_follow_when_playing
  min_music_duration_value: !input min_music_duration_seconds
  protect_target_playback_flag: !input protect_target_playback
  treat_unknown_duration_as_music_flag: !input treat_unknown_duration_as_music
  voice_assistant_guard_entity: !input voice_assistant_guard

trigger:
  - platform: state
    entity_id: !input presence_sensors
    from: "off"
    to: "on"
    for: !input min_presence_on_time

condition:
  # Global follow switch must be ON
  - condition: state
    entity_id: !input follow_switch
    state: "on"

  # Optional: persons must be home
  - condition: template
    value_template: >
      {% if not require_person %}
        true
      {% else %}
        {% set ns = namespace(home=false) %}
        {% for p in person_list %}
          {% if states(p) == 'home' %}
            {% set ns.home = true %}
          {% endif %}
        {% endfor %}
        {{ ns.home }}
      {% endif %}

  # Global cooldown since last successful transfer (optional)
  - condition: template
    alias: "Global cooldown (since last successful transfer)"
    value_template: >
      {% set cooldown = cooldown_seconds_value | int(0) %}
      {% if cooldown == 0 or not cooldown_helper_entity %}
        true
      {% else %}
        {% set last = states(cooldown_helper_entity) %}
        {% if last in ['unknown', 'unavailable', ''] %}
          true
        {% else %}
          {% set last_dt = as_datetime(last) %}
          {% if last_dt is none %}
            true
          {% else %}
            {{ (now().timestamp() - last_dt.timestamp()) >= cooldown }}
          {% endif %}
        {% endif %}
      {% endif %}
      
  # Block while voice assistant is active (optional)
  - condition: template
    alias: "Block while voice assistant guard is ON (optional)"
    value_template: >
      {% if not voice_assistant_guard_entity %}
        true
      {% else %}
        {{ states(voice_assistant_guard_entity) != 'on' }}
      {% endif %}

action:
  # 1) Compute target_player, *music* source player, any_music_playing, and indices
  - variables:
      trigger_entity: "{{ trigger.entity_id }}"

      # Index of the presence sensor that just triggered
      target_index: >
        {% set ns = namespace(idx=-1) %}
        {% for s in presence_list %}
          {% if s == trigger_entity and ns.idx == -1 %}
            {% set ns.idx = loop.index0 %}
          {% endif %}
        {% endfor %}
        {{ ns.idx }}

      # Player mapped to the triggering sensor
      target_player: >
        {% set ti = target_index | int(-1) %}
        {% if ti == -1 %}
          {{ '' }}
        {% else %}
          {{ player_list[ti] }}
        {% endif %}

      # Helper: numeric min duration
      min_music_duration: "{{ min_music_duration_value | int(0) }}"

      # First player that looks like it has a real music queue (not just a tiny TTS clip)
      music_source_player: >
        {% set ns = namespace(src='') %}
        {% for p in player_list %}
          {% if states(p) in ['playing', 'paused', 'buffering'] and ns.src == '' %}
            {% set dur = state_attr(p, 'media_duration') | default(0) | float(0) %}
            {% if (dur == 0 and treat_unknown_duration_as_music_flag)
                  or (dur > 0 and dur >= min_music_duration) %}
              {% set ns.src = p %}
            {% endif %}
          {% endif %}
        {% endfor %}
        {{ ns.src }}

      any_music_playing: >
        {% set ns = namespace(any=false) %}
        {% for p in player_list %}
          {% if states(p) == 'playing' %}
            {% set dur = state_attr(p, 'media_duration') | default(0) | float(0) %}
            {% if (dur == 0 and treat_unknown_duration_as_music_flag)
                  or (dur > 0 and dur >= min_music_duration) %}
              {% set ns.any = true %}
            {% endif %}
          {% endif %}
        {% endfor %}
        {{ ns.any }}

      # Index of the source player in the player_list (if any)
      source_index: >
        {% set ns = namespace(idx=-1) %}
        {% for p in player_list %}
          {% if p == music_source_player and ns.idx == -1 %}
            {% set ns.idx = loop.index0 %}
          {% endif %}
        {% endfor %}
        {{ ns.idx }}

      # Target player active state
      target_state: "{{ states(target_player) | default('unknown') }}"

  # 2) Optional: only follow when playing
  - condition: template
    alias: "Only follow when playing (optional)"
    value_template: >
      {% if not only_follow_when_playing_flag %}
        true
      {% else %}
        {{ any_music_playing | bool }}
      {% endif %}

  # 3) Basic safety: valid target, valid source, and don't spam same-room transfers
  - condition: template
    alias: "Valid target and source, not same"
    value_template: >
      {{ target_player != '' and music_source_player != '' and target_player != music_source_player }}

  # 4) Allowed source players (optional)
  - condition: template
    alias: "Allowed source players (optional)"
    value_template: >
      {% if allowed_source_players_list | length == 0 %}
        true
      {% else %}
        {{ music_source_player in allowed_source_players_list }}
      {% endif %}

  # 5) Priority anchor (optional)
  - condition: template
    alias: "Priority anchor (optional)"
    value_template: >
      {% if not enforce_priority_anchor_flag %}
        true
      {% else %}
        {% set src_idx = source_index | int(-1) %}
        {% set tgt_idx = target_index | int(-1) %}
        {# if we can't map either index, don't anchor #}
        {% if src_idx == -1 or tgt_idx == -1 %}
          true
        {% else %}
          {# is the source zone still active? #}
          {% set src_active = (states(presence_list[src_idx]) == 'on') %}
          {% if not src_active %}
            true
          {% else %}
            {# allow only if moving UP in priority (lower index) #}
            {{ tgt_idx < src_idx }}
          {% endif %}
        {% endif %}
      {% endif %}

  # 6) Protect target playback (optional)
  - condition: template
    alias: "Protect target playback (optional)"
    value_template: >
      {% if not protect_target_playback_flag %}
        true
      {% else %}
        {{ target_state not in ['playing', 'buffering'] }}
      {% endif %}

  # 7) Optional pre-transfer announcement (only when music is actually playing)
  - choose:
      - conditions:
          - condition: template
            value_template: >
              {{ pre_announcements_enabled_flag | bool
                 and pre_announcement_script_entity is not none
                 and pre_announcement_script_entity != ''
                 and any_music_playing | bool }}
        sequence:
          - service: script.turn_on
            target:
              entity_id: "{{ pre_announcement_script_entity }}"
            data:
              variables:
                target_player: "{{ target_player }}"
                source_player: "{{ music_source_player }}"

  # 8) Optional delay before transfer (gives TTS some head start)
  - delay:
      seconds: "{{ delay_seconds_value | int(0) }}"

  # 9) Transfer the queue via Music Assistant
  - choose:
      # Case: some music-like playback is currently playing -> move + auto_play true
      - conditions:
          - condition: template
            value_template: "{{ any_music_playing | bool }}"
        sequence:
          - service: music_assistant.transfer_queue
            target:
              entity_id: "{{ target_player }}"
            data:
              source_player: "{{ music_source_player }}"
              auto_play: true
    # Default: nothing music-like playing -> move but keep paused
    default:
      - service: music_assistant.transfer_queue
        target:
          entity_id: "{{ target_player }}"
        data:
          source_player: "{{ music_source_player }}"
          auto_play: false

  # 10) Update cooldown helper timestamp after successful transfer
  - choose:
      - conditions:
          - condition: template
            value_template: >
              {{ cooldown_seconds_value | int(0) > 0
                 and cooldown_helper_entity is not none
                 and cooldown_helper_entity != '' }}
        sequence:
          - service: input_datetime.set_datetime
            target:
              entity_id: "{{ cooldown_helper_entity }}"
            data:
              datetime: "{{ now().isoformat() }}"

  # 11) Optional post-transfer announcement (only when music is actually playing)
  - choose:
      - conditions:
          - condition: template
            value_template: >
              {{ announcements_enabled_flag | bool
                 and announcement_script_entity is not none
                 and announcement_script_entity != ''
                 and any_music_playing | bool }}
        sequence:
          - service: script.turn_on
            target:
              entity_id: "{{ announcement_script_entity }}"
            data:
              variables:
                target_player: "{{ target_player }}"
                source_player: "{{ music_source_player }}"
