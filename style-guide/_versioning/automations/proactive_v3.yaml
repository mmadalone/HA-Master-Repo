blueprint:
  name: "Proactive – Presence-based suggestions (v3)"
  description: >
    When presence is detected in an area during a configured time window,
    proactively speaks a message via TTS. Messages are read from
    input_text helpers (morning/afternoon/evening), so they can be
    generated or refreshed by another automation (e.g. an AI-based
    'refresh lines' automation). Includes a configurable cooldown
    to avoid spam. Supports both standard TTS entities (tts.speak) and
    the ElevenLabs custom integration (tts.elevenlabs_custom_tts with
    voice_profile). Optionally keeps nagging while you stay in the area,
    can press a refresh button after each run to regenerate messages,
    and can ask a bedtime yes/no question via an Assist Satellite
    (Voice Preview) and call a bedtime script when you say yes.
  domain: automation
  source_url: "https://chatgpt.local/proactive_quark_presence_v3"

  input:
    presence_sensors:
      name: Presence sensors for this area
      description: >
        One or more binary sensors that indicate presence in this area
        (e.g. FP2 room groups for Living room, Workshop, etc.).
        The automation will fire when ANY of these is used as a trigger.
      selector:
        entity:
          domain: binary_sensor
          multiple: true

    bedtime_question_delay:
      name: Delay between evening message and bedtime question (seconds)
      description: >
        How long to wait after the Evening message TTS before asking
        the bedtime question. Needed because some TTS integrations
        (like ElevenLabs) mark the player as idle before the audio is
        fully finished.
      default: 5
      selector:
        number:
          min: 0
          max: 30
          unit_of_measurement: seconds
          mode: slider
          step: 1

    media_player:
      name: Speaker / media player to speak from
      description: >
        Media player should use to talk in this area.
        Can be a Home Assistant Voice Preview speaker, Sonos, etc.
      selector:
        entity:
          domain: media_player

    tts_mode:
      name: TTS mode
      description: >
        Choose how it should speak:
        - "standard_tts_entity": Use any TTS entity via tts.speak
          (recommended for official ElevenLabs and other HA TTS).
        - "elevenlabs_custom_service": Use the HACS ElevenLabs custom
          integration entity (tts.elevenlabs_custom_tts) via tts.speak
          with options.voice_profile.
      default: standard_tts_entity
      selector:
        select:
          options:
            - standard_tts_entity
            - elevenlabs_custom_service

    tts_entity:
      name: TTS entity to use with tts.speak
      description: >
        TTS entity used by tts.speak.
        Examples:
        - For official ElevenLabs: tts.elevenlabs
        - For custom 11Labs: tts.elevenlabs_custom_tts
        - Any other TTS entity also works.
      selector:
        entity:
          domain: tts

    elevenlabs_voice_profile:
      name: ElevenLabs voice profile (for custom mode)
      description: >
        Only used when TTS mode is "elevenlabs_custom_service".
        Voice profile name/ID for the ElevenLabs custom integration,
        e.g. "Quark - Custom 11". Should match your working
        tts.speak options.voice_profile.
      default: ""
      selector:
        text:
          multiline: false

    area_name:
      name: Area name (for the message)
      description: >
        Friendly name of this area for it to mention in his speech.
        This is a menu with common room names, but you can also type
        your own value. Used in fallback messages and can be referenced
        in AI-generated text.
      default: Workshop
      selector:
        select:
          options:
            - Workshop
            - Living room
            - Bedroom
            - Office
            - Kitchen
            - Bathroom
          custom_value: true

    start_time:
      name: Active from
      description: >
        Start time of the daily window where allowed to be
        proactive in this area.
      default: "08:00:00"
      selector:
        time: {}

    end_time:
      name: Active until
      description: >
        End time of the daily window where allowed to be
        proactive in this area. Can be earlier than "Active from" to
        create a window that crosses midnight (e.g. 23:00 → 02:00).
      default: "23:00:00"
      selector:
        time: {}

    cooldown_minutes:
      name: Cooldown / nag interval (minutes)
      description: >
        Minimum time between proactive messages in this area. When
        'Keep nagging while present' is enabled, this acts as the nag
        interval while presence is on. Default is 30 minutes.
      default: 30
      selector:
        number:
          min: 1
          max: 240
          step: 1
          unit_of_measurement: "min"

    repeat_while_present:
      name: Keep nagging while present
      description: >
        If enabled, will keep nagging at the chosen interval
        (cooldown) as long as at least one presence sensor is on within
        the active time window. If disabled, he only speaks when presence
        turns on (until you leave and re-enter). The bedtime time trigger
        is independent of this and will fire at "Active from" if presence
        is detected.
      default: false
      selector:
        boolean: {}

    max_nags_per_session:
      name: Max nags per presence session (0 = unlimited)
      description: >
        Only used when 'Keep nagging while present' is enabled.
        0 = nag indefinitely until you leave the area.
        >0 = stop nagging after roughly this many messages while the
        area remains occupied. A 'session' ends when all presence
        sensors are off.
      default: 0
      selector:
        number:
          min: 0
          max: 20
          step: 1

    message_morning_helper:
      name: Morning message input_text
      description: >
        input_text entity where the MORNING message for this area is
        stored. Typically filled by an AI refresh automation, but you
        can also set it manually.
      selector:
        entity:
          domain: input_text

    message_afternoon_helper:
      name: Afternoon message input_text
      description: >
        input_text entity where the AFTERNOON message for this area is
        stored.
      selector:
        entity:
          domain: input_text

    message_evening_helper:
      name: Evening message input_text
      description: >
        input_text entity where the EVENING/NIGHT message for this area
        is stored. In bedtime mode this is always the one that will be
        spoken.
      selector:
        entity:
          domain: input_text

    refresh_after_run:
      name: Refresh messages after each run
      description: >
        If enabled, will press the configured refresh button after
        speaking, so a separate AI refresh automation can generate new
        messages for next time.
      default: false
      selector:
        boolean: {}

    refresh_button:
      name: Refresh button to press
      description: >
        input_button that triggers the AI "Refresh messages"
        automation for this area (e.g. workshop, living room, bedtime).
        It will only be pressed if "Refresh messages after each run"
        is enabled.
      selector:
        entity:
          domain: input_button

    enable_bedtime_question:
      name: Ask if you want help going to bed
      description: >
        If enabled, after it speaks he will ask a yes/no question on
        the selected Assist Satellite (Voice Preview), such as
        "Miquel, do you want me to help you go to bed now?" and capture
        the answer. If you say yes, the selected bedtime script will run.
        Enable this only for your bedtime automation instance.
      default: false
      selector:
        boolean: {}

    bedtime_assist_satellite:
      name: Assist Satellite for bedtime question
      description: >
        Assist Satellite (Voice Preview) entity that should ask the
        bedtime question. Typically the satellite in the same area as
        the media player.
      selector:
        entity:
          domain: assist_satellite

    bedtime_question_text:
      name: Bedtime question text
      description: >
        The question it should ask, e.g. "Miquel, do you want me to
        help you go to bed now?"
      default: "Miquel, do you want me to help you go to bed now?"
      selector:
        text:
          multiline: true

    bedtime_help_script:
      name: Script to run when you say yes
      description: >
        Script that will be called when the bedtime question is answered
        with YES. This should be your 'put me to bed' routine. You will
        create this script separately (e.g. via a script blueprint) and
        then select it here.
      selector:
        entity:
          domain: script

mode: single
max_exceeded: silent

variables:
  cooldown: !input cooldown_minutes
  refresh_after_run: !input refresh_after_run
  refresh_button: !input refresh_button
  presence_entities: !input presence_sensors
  repeat_while_present: !input repeat_while_present
  max_nags_per_session: !input max_nags_per_session

  enable_bedtime_question: !input enable_bedtime_question
  bedtime_assist_satellite: !input bedtime_assist_satellite
  bedtime_question_text: !input bedtime_question_text
  bedtime_help_script: !input bedtime_help_script
  bedtime_question_delay: !input bedtime_question_delay

trigger:
  # First nag: presence goes from off → on
  - platform: state
    entity_id: !input presence_sensors
    from: "off"
    to: "on"

  # Repeated nags: periodic tick, filtered by conditions below
  - platform: time_pattern
    minutes: "/1"    # check every minute, actual interval = cooldown_minutes

  # Bedtime: exact "Active from" time each day
  - platform: time
    at: !input start_time

condition:
  # Time window
  - condition: time
    after: !input start_time
    before: !input end_time

  # Must still be present in the area
  - condition: template
    alias: "Presence still detected"
    value_template: >
      {% set sensors = presence_entities %}
      {{ expand(sensors) | selectattr('state', 'eq', 'on') | list | length > 0 }}

  # Only allow time_pattern-based runs when repeat_while_present = true
  - condition: template
    alias: "Trigger allowed by repeat mode"
    value_template: >
      {% if not repeat_while_present and trigger.platform == 'time_pattern' %}
        false
      {% else %}
        true
      {% endif %}

  # Cooldown + max nags per session
  - condition: template
    alias: "Cooldown and max nags per session"
    value_template: >
      {% set mins = cooldown | int %}
      {% set max_nags = max_nags_per_session | int %}
      {% set last = this.attributes.last_triggered %}
      {% set enough_time = last is none
        or (as_timestamp(now()) - as_timestamp(last)) > (mins * 60) %}
      {% if not enough_time %}
        false
      {% elif max_nags == 0 %}
        true
      {% else %}
        {% set sensors = presence_entities %}
        {% set on_sensors = expand(sensors)
          | selectattr('state', 'eq', 'on') | list %}
        {% if on_sensors | length == 0 %}
          true
        {% else %}
          {% set session_start = (on_sensors
              | map(attribute='last_changed') | min) %}
          {% set max_duration = max_nags * mins * 60 %}
          {{ (as_timestamp(now()) - as_timestamp(session_start)) < max_duration }}
        {% endif %}
      {% endif %}

action:
  - variables:
      player: !input media_player
      tts_mode: !input tts_mode
      tts_entity: !input tts_entity
      area_name: !input area_name
      voice_profile: !input elevenlabs_voice_profile

      morning_entity: !input message_morning_helper
      afternoon_entity: !input message_afternoon_helper
      evening_entity: !input message_evening_helper

      tod_label: >
        {% if enable_bedtime_question %}
          evening
        {% else %}
          {% set h = now().hour %}
          {% if 5 <= h < 12 %}
            morning
          {% elif 12 <= h < 18 %}
            afternoon
          {% else %}
            evening
          {% endif %}
        {% endif %}

      proactive_message: >
        {% set morning = states(morning_entity) %}
        {% set afternoon = states(afternoon_entity) %}
        {% set evening = states(evening_entity) %}
        {% if tod_label == 'morning' %}
          {% if morning | trim == '' %}
            Good {{ tod_label }}, you just stepped into the {{ area_name }}.
            Want me to start your usual chaos… I mean, music?
          {% else %}
            {{ morning }}
          {% endif %}
        {% elif tod_label == 'afternoon' %}
          {% if afternoon | trim == '' %}
            Back in the {{ area_name }}, huh? Need me to resume your tunes
            or handle something for you?
          {% else %}
            {{ afternoon }}
          {% endif %}
        {% else %}
          {% if evening | trim == '' %}
            It's {{ tod_label }} in the {{ area_name }}.
            I can spin something relaxing or set the mood. Just say the word.
          {% else %}
            {{ evening }}
          {% endif %}
        {% endif %}

  - choose:
      - conditions:
          - condition: template
            value_template: "{{ tts_mode == 'elevenlabs_custom_service' }}"
        sequence:
          - service: tts.speak
            target:
              entity_id: "{{ tts_entity }}"
            data:
              message: "{{ proactive_message }}"
              media_player_entity_id: "{{ player }}"
              options:
                voice_profile: "{{ voice_profile }}"

      - conditions:
          - condition: template
            value_template: "{{ tts_mode == 'standard_tts_entity' }}"
        sequence:
          - service: tts.speak
            target:
              entity_id: "{{ tts_entity }}"
            data:
              message: "{{ proactive_message }}"
              media_player_entity_id: "{{ player }}"

  - if:
      - condition: template
        value_template: "{{ refresh_after_run and not enable_bedtime_question }}"
    then:
      - service: input_button.press
        target:
          entity_id: "{{ refresh_button }}"

  - if:
      - condition: template
        value_template: "{{ enable_bedtime_question }}"
    then:
      - delay:
          seconds: "{{ bedtime_question_delay | int }}"

      - action: assist_satellite.ask_question
        continue_on_error: true
        data:
          entity_id: "{{ bedtime_assist_satellite }}"
          question: "{{ bedtime_question_text }}"
          answers:
            - id: "yes"
              sentences:
                - "yes"
                - "yeah"
                - "sure"
                - "ok"
                - "okay"
                - "please"
            - id: "no"
              sentences:
                - "no"
                - "no thanks"
                - "not now"
                - "cancel"
        response_variable: bedtime_answer

      - choose:
          - conditions:
              - condition: template
                value_template: "{{ bedtime_answer is defined and bedtime_answer.id == 'yes' }}"
            sequence:
              - action: script.turn_on
                target:
                  entity_id: "{{ bedtime_help_script }}"
