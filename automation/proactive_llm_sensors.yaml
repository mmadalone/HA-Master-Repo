blueprint:
  name: "Proactive – Presence-based suggestions"
  author: madalone
  description: '![Proactive LLM Sensors](https://raw.githubusercontent.com/mmadalone/HA-Master-Repo/main/images/header/proactive_llm_sensors-header.jpeg)

    # Proactive – Presence-based suggestions

    When presence is detected in an area during a configured time window,
    proactively speaks a message via TTS. Messages are generated on the
    fly by a Conversation / LLM agent using a prompt you configure in
    this automation. Includes configurable cooldown, optional repeated
    nagging while present, support for both standard TTS entities and the
    ElevenLabs custom integration, and an optional bedtime yes/no question
    via an Assist Satellite that can call a bedtime script when you say yes.
    Extra sensors/entities can be passed as live context for the LLM.

    ### Recent changes

    - **v7.3:** Audit fixes — presence_sensors default "" → [] for
      multi-entity selector, "Stage N" references → circled-number
      section labels, tightened chosen_user_name whitespace,
      sensor_context for-loop whitespace control tags

    - **v7.2:** Audit fixes — nag tick interval /1→/5 to reduce event bus
      load, gender-neutral default bedtime prompt, min_presence_seconds
      anchors to earliest ON sensor (| min), added source_url

    - **v7.1:** Cross-midnight day attribution fix — effective_day_key
      shifts post-midnight hours to the previous day''s run_days entry,
      preventing unwanted evening activations on the next calendar day

    - **v7:** Section key/name convention alignment, > → >- on all computed
      template variables, YAML comment dividers between input sections

    - **v6:** Style guide compliance — collapsible input sections, aliases on
      all actions, service→action migration, template safety, error handling
      on LLM calls, user_name input replacing hardcoded name

    - **v5:** Weekday controls + weekend profile with separate schedule,
      cooldown, prompt overrides, and bedtime behavior per weekend days'
  domain: automation
  source_url: "https://github.com/mmadalone/HA-Master-Repo/blob/main/automation/proactive_llm_sensors.yaml"
  homeassistant:
    min_version: "2024.10.0"

  input:
    # ===========================================================================
    # ① PRESENCE & DETECTION
    # ===========================================================================
    presence_detection:
      name: "① Presence & detection"
      icon: mdi:motion-sensor
      description: Configure how presence is detected and optional guards.
      collapsed: false
      input:
        presence_sensors:
          name: Presence sensors for this area
          description: >
            One or more binary sensors that indicate presence in this area
            (e.g. FP2 room groups for Living room, Workshop, etc.).
            The automation fires when ANY of these transitions to ON.
          selector:
            entity:
              domain: binary_sensor
              device_class: occupancy
              multiple: true
          default: []

        min_presence_seconds:
          name: Minimum presence duration (seconds)
          description: >
            If set above 0, the automation only speaks when presence has been
            continuously detected for at least this long. Prevents quick
            walk-by triggers from firing.
          default: 0
          selector:
            number:
              min: 0
              max: 600
              step: 5
              unit_of_measurement: seconds

        block_if_media_playing:
          name: Do not speak if media is playing
          description: >
            If enabled, the automation will not speak while the selected
            media player is actively playing. Avoids talking over music,
            podcasts, or TV audio.
          default: false
          selector:
            boolean: {}

    # ===========================================================================
    # ② TTS & SPEAKER
    # ===========================================================================
    tts_speaker:
      name: "② TTS & speaker"
      icon: mdi:speaker-message
      description: Configure which speaker and TTS integration to use.
      collapsed: true
      input:
        media_player:
          name: Speaker / media player to speak from
          description: >
            Media player that should talk in this area.
            Can be a Home Assistant Voice Preview speaker, Sonos, etc.
          default: ""
          selector:
            entity:
              domain: media_player

        tts_mode:
          name: TTS mode
          description: >
            Choose which TTS integration to use for speech output.
          default: standard_tts_entity
          selector:
            select:
              options:
                - label: "Standard — any tts.speak entity"
                  value: standard_tts_entity
                - label: "ElevenLabs custom — uses options.voice_profile"
                  value: elevenlabs_custom_service

        tts_entity:
          name: TTS entity to use with tts.speak
          description: >
            TTS entity used by tts.speak. Examples: tts.elevenlabs for
            official ElevenLabs, tts.elevenlabs_custom_tts for custom
            11Labs, or any other TTS entity.
          default: ""
          selector:
            entity:
              domain: tts

        elevenlabs_voice_profile:
          name: ElevenLabs voice profile (for custom mode)
          description: >
            Only used when TTS mode is "ElevenLabs custom". Voice profile
            name/ID for the ElevenLabs custom integration, e.g.
            "Quark - Custom 11". Must match your tts.speak
            options.voice_profile value.
          default: ""
          selector:
            text:
              multiline: false

        area_name:
          name: Area name (for the message)
          description: >
            Friendly name of this area for mention in speech. Used in
            fallback messages and can be referenced in AI-generated text.
            Pick from the menu or type a custom value.
          default: Workshop
          selector:
            select:
              options:
                - Workshop
                - Living room
                - Bedroom
                - Office
                - Kitchen
                - Bathroom
              custom_value: true

    # ===========================================================================
    # ③ AI CONVERSATION
    # ===========================================================================
    ai_conversation:
      name: "③ AI conversation"
      icon: mdi:robot
      description: Configure the conversation agent, prompts, and context.
      collapsed: true
      input:
        user_names:
          name: User names / nicknames (optional)
          description: >
            Comma-separated list of names or nicknames for the person.
            One is picked randomly each time the automation runs, adding
            variety. Leave empty to use the generic fallback names below.
            Example: "Miquel, Miky, boss"
          default: ""
          selector:
            text:
              multiline: false

        fallback_names:
          name: Fallback address terms (direct speech)
          description: >
            Comma-separated generic terms for addressing the person in
            spoken TTS when no user name is set. These are 2nd-person
            terms used in direct speech. One is picked randomly each run.
            Example: "friend, hey there, mate"
          default: "friend, hey there"
          selector:
            text:
              multiline: false

        llm_fallback_names:
          name: Fallback reference terms (LLM prompts)
          description: >
            Comma-separated generic terms used in LLM prompt instructions
            when no user name is set. These are 3rd-person references
            telling the AI who it's talking to. One picked randomly.
            Example: "the user, the person, them"
          default: "the user"
          selector:
            text:
              multiline: false

        conversation_agent:
          name: Conversation / LLM agent
          description: >
            Conversation agent that generates the proactive sentence and,
            optionally, the bedtime question. Can be OpenAI Conversation,
            Extended OpenAI Conversation, Llama, or any agent that supports
            conversation.process.
          default: ""
          selector:
            conversation_agent:

        llm_prompt:
          name: LLM prompt / style for proactive messages
          description: >
            Instructions for how the AI should talk when generating the
            proactive presence-based line. Combined with area name, time of
            day, trigger type, and extra sensor context before being sent
            to the conversation agent.
          default: >
            You are a smart home assistant. Reply with ONE short, playful sentence you would say
            out loud to the user in this area right now, maximum 220 characters
            and without quotation marks.
          selector:
            text:
              multiline: true

        context_entities:
          name: Extra context sensors/entities for the LLM
          description: >
            Optional. Sensors or other entities whose current states are
            passed to the LLM as extra context (e.g. temperatures, UPS
            status, media players, CPU temp, lights). Included as a simple
            text list in the prompt.
          default: []
          selector:
            entity:
              multiple: true

    # ===========================================================================
    # ④ SCHEDULE & TIMING
    # ===========================================================================
    schedule_timing:
      name: "④ Schedule & timing"
      icon: mdi:clock-outline
      description: Configure when the automation is active and cooldown behavior.
      collapsed: true
      input:
        start_time:
          name: Active from
          description: >
            Start time of the daily window where the automation is allowed
            to be proactive in this area.
          default: "08:00:00"
          selector:
            time: {}

        end_time:
          name: Active until
          description: >
            End time of the daily window. Can be earlier than "Active from"
            to create a window that crosses midnight (e.g. 23:00 → 02:00).
          default: "23:00:00"
          selector:
            time: {}

        run_days:
          name: Run on these days
          description: >
            Days of the week this automation is allowed to run. If today is
            not selected, no message will be generated and no TTS will play.
          default:
            - mon
            - tue
            - wed
            - thu
            - fri
            - sat
            - sun
          selector:
            select:
              options:
                - label: "Monday"
                  value: mon
                - label: "Tuesday"
                  value: tue
                - label: "Wednesday"
                  value: wed
                - label: "Thursday"
                  value: thu
                - label: "Friday"
                  value: fri
                - label: "Saturday"
                  value: sat
                - label: "Sunday"
                  value: sun
              multiple: true

        cooldown_minutes:
          name: Cooldown / nag interval (minutes)
          description: >
            Minimum time between proactive messages in this area. When
            "Keep nagging while present" is enabled, this acts as the nag
            interval while presence is on. Default is 30 minutes.
          default: 30
          selector:
            number:
              min: 1
              max: 240
              step: 1
              unit_of_measurement: "min"

        repeat_while_present:
          name: Keep nagging while present
          description: >
            If enabled, keeps nagging at the chosen cooldown interval as
            long as at least one presence sensor is on within the active
            time window. If disabled, only speaks when presence turns on
            (until you leave and re-enter).
          default: false
          selector:
            boolean: {}

        max_nags_per_session:
          name: Max nags per presence session (0 = unlimited)
          description: >
            Only used when "Keep nagging" is enabled. Limits how many times
            it can nag while presence stays on. Session start is the
            earliest last_changed among the ON sensors; max session
            duration = cooldown × max_nags. Set to 0 for unlimited.
          default: 3
          selector:
            number:
              min: 0
              max: 48
              step: 1

    # ===========================================================================
    # ⑤ WEEKEND OVERRIDES
    # ===========================================================================
    weekend_overrides:
      name: "⑤ Weekend overrides"
      icon: mdi:weather-sunny
      description: >
        Optional weekend-specific schedule, cooldown, and prompt overrides.
        Only applies when Weekend behavior is set to "use_weekend_profile".
      collapsed: true
      input:
        weekend_mode:
          name: Weekend behavior
          description: >
            Choose what happens on "weekend" days (as defined below).
          default: same_as_weekdays
          selector:
            select:
              options:
                - label: "Same as weekdays"
                  value: same_as_weekdays
                - label: "Disabled on weekends"
                  value: disabled_on_weekends
                - label: "Use weekend profile"
                  value: use_weekend_profile

        weekend_days:
          name: Weekend days
          description: >
            Which days should be treated as "weekend" for the setting above.
            Only used for weekend behavior; does not override "Run on these
            days" in ④ Schedule & timing.
          default:
            - sat
            - sun
          selector:
            select:
              options:
                - label: "Monday"
                  value: mon
                - label: "Tuesday"
                  value: tue
                - label: "Wednesday"
                  value: wed
                - label: "Thursday"
                  value: thu
                - label: "Friday"
                  value: fri
                - label: "Saturday"
                  value: sat
                - label: "Sunday"
                  value: sun
              multiple: true

        weekend_start_time:
          name: Weekend active from
          description: >
            Start time for weekend days when using the weekend profile.
          default: "08:00:00"
          selector:
            time: {}

        weekend_end_time:
          name: Weekend active until
          description: >
            End time for weekend days when using the weekend profile.
            Can be earlier than start time to cross midnight.
          default: "23:00:00"
          selector:
            time: {}

        weekend_cooldown_minutes:
          name: Weekend cooldown / nag interval (minutes)
          description: >
            Cooldown/nag interval for weekend days when using the weekend
            profile.
          default: 30
          selector:
            number:
              min: 1
              max: 240
              step: 1
              unit_of_measurement: "min"

        weekend_llm_prompt_override:
          name: Weekend LLM prompt override (optional)
          description: >
            Alternate prompt to use on weekend days when using the weekend
            profile. If left blank, the normal prompt is used.
          default: ""
          selector:
            text:
              multiline: true

    # ===========================================================================
    # ⑥ BEDTIME QUESTION
    # ===========================================================================
    bedtime_question:
      name: "⑥ Bedtime question"
      icon: mdi:bed
      description: >
        Optional bedtime yes/no question via Assist Satellite after TTS.
        If you answer YES, a bedtime script can be run automatically.
      collapsed: true
      input:
        enable_bedtime_question:
          name: Ask if you want help going to bed
          description: >
            If enabled, after the proactive TTS message, a yes/no bedtime
            question is asked on the selected Assist Satellite. If you
            answer YES, the bedtime script runs.
          default: false
          selector:
            boolean: {}

        bedtime_assist_satellite:
          name: Assist Satellite for bedtime question
          description: >
            Assist Satellite (Voice Preview) entity that should ask the
            bedtime question. Typically the satellite in the same area as
            the media player.
          default: ""
          selector:
            entity:
              domain: assist_satellite

        bedtime_question_delay:
          name: Delay between TTS and bedtime question (seconds)
          description: >
            How long to wait after the proactive TTS message before asking
            the bedtime question. Needed because some TTS integrations
            may still be playing audio when the media player looks idle.
          default: 5
          selector:
            number:
              min: 0
              max: 30
              unit_of_measurement: seconds
              mode: slider
              step: 1

        bedtime_llm_prompt:
          name: Bedtime LLM prompt / style
          description: >
            Instructions for how the AI should phrase the bedtime question.
            The blueprint asks the LLM to produce one short yes/no question
            about going to bed, receiving the extra sensor context.
          default: >
            You are a smart home assistant speaking to a user at bedtime. Ask ONE short yes/no
            question to check if they want to go to bed now or start their
            bedtime routine. Maximum 200 characters, no quotation marks.
          selector:
            text:
              multiline: true

        bedtime_question_text:
          name: Fallback bedtime question text
          description: >
            Fallback text if the LLM fails to generate a bedtime question.
            Should be a short yes/no question. The user name from ③ AI
            conversation is NOT automatically inserted here — write the
            full question.
          default: "Do you want me to help you go to bed now?"
          selector:
            text:
              multiline: true

        bedtime_help_script:
          name: Script to run when you say yes
          description: >
            Script called when the bedtime question is answered with YES.
            This should be your bedtime routine script, created separately.
            Leave empty if not using this feature.
          default: ""
          selector:
            entity:
              domain: script

        weekend_bedtime_mode:
          name: Weekend bedtime question
          description: >
            Optionally change bedtime behavior on weekend days when using
            the weekend profile from ⑤ Weekend overrides.
          default: same_as_weekdays
          selector:
            select:
              options:
                - label: "Same as weekdays"
                  value: same_as_weekdays
                - label: "Disabled on weekends"
                  value: disabled
                - label: "Use weekend bedtime prompt"
                  value: use_weekend_bedtime_prompt

        weekend_bedtime_llm_prompt_override:
          name: Weekend bedtime LLM prompt override (optional)
          description: >
            Alternate bedtime question prompt for weekend days when using
            the weekend bedtime prompt. If left blank, the normal bedtime
            prompt is used.
          default: ""
          selector:
            text:
              multiline: true

mode: single
max_exceeded: silent

trace:
  stored_traces: 15

variables:
  # core
  presence_entities: !input presence_sensors
  repeat_while_present: !input repeat_while_present
  max_nags_per_session: !input max_nags_per_session
  player_entity: !input media_player
  user_names_raw: !input user_names
  fallback_names_raw: !input fallback_names
  llm_fallback_names_raw: !input llm_fallback_names

  # Pick one real name (shared across both contexts when available)
  chosen_user_name: >-
    {% set names = (user_names_raw | default('', true)).split(',')
        | map('trim') | reject('eq', '') | list %}
    {{ names | random if names | length > 0 else '' }}

  # Direct address in spoken TTS — falls back to "friend" pool
  chosen_direct_name: >-
    {% set real = (chosen_user_name | default('', true)) | trim %}
    {% if real %}
      {{ real }}
    {% else %}
      {% set fb = (fallback_names_raw | default('friend', true)).split(',')
          | map('trim') | reject('eq', '') | list %}
      {{ fb | random if fb | length > 0 else 'friend' }}
    {% endif %}

  # 3rd-person reference in LLM prompt instructions — falls back to "the user" pool
  chosen_llm_name: >-
    {% set real = (chosen_user_name | default('', true)) | trim %}
    {% if real %}
      {{ real }}
    {% else %}
      {% set fb = (llm_fallback_names_raw | default('the user', true)).split(',')
          | map('trim') | reject('eq', '') | list %}
      {{ fb | random if fb | length > 0 else 'the user' }}
    {% endif %}

  # weekday selection + optional weekend profile
  run_days: !input run_days
  weekend_mode: !input weekend_mode
  weekend_days: !input weekend_days

  weekday_start_time: !input start_time
  weekday_end_time: !input end_time
  weekday_cooldown_minutes: !input cooldown_minutes

  weekend_start_time: !input weekend_start_time
  weekend_end_time: !input weekend_end_time
  weekend_cooldown_minutes: !input weekend_cooldown_minutes

  llm_prompt_base: !input llm_prompt
  weekend_llm_prompt_override: !input weekend_llm_prompt_override

  today_key: >-
    {% set days = ['mon','tue','wed','thu','fri','sat','sun'] %}
    {{ days[now().weekday()] }}

  is_weekend: >-
    {{ today_key in (weekend_days | default([])) }}

  weekend_profile_active: >-
    {{ is_weekend and (weekend_mode | default('same_as_weekdays')) == 'use_weekend_profile' }}

  weekend_blocked: >-
    {{ is_weekend and (weekend_mode | default('same_as_weekdays')) == 'disabled_on_weekends' }}

  effective_start_time: >-
    {% if weekend_profile_active %}
      {{ weekend_start_time | default('08:00:00') }}
    {% else %}
      {{ weekday_start_time | default('08:00:00') }}
    {% endif %}

  effective_end_time: >-
    {% if weekend_profile_active %}
      {{ weekend_end_time | default('23:00:00') }}
    {% else %}
      {{ weekday_end_time | default('23:00:00') }}
    {% endif %}

  effective_day_key: >-
    {% set days = ['mon','tue','wed','thu','fri','sat','sun'] %}
    {% set start = today_at(effective_start_time) %}
    {% set end = today_at(effective_end_time) %}
    {% set crosses_midnight = as_timestamp(end) < as_timestamp(start) %}
    {% if crosses_midnight and now() < end %}
      {{ days[(now().weekday() - 1) % 7] }}
    {% else %}
      {{ today_key }}
    {% endif %}

  cooldown: >-
    {% if weekend_profile_active %}
      {{ (weekend_cooldown_minutes | default(30)) | int }}
    {% else %}
      {{ (weekday_cooldown_minutes | default(30)) | int }}
    {% endif %}

  llm_prompt: >-
    {% if weekend_profile_active and ((weekend_llm_prompt_override | default('')) | trim) %}
      {{ weekend_llm_prompt_override }}
    {% else %}
      {{ llm_prompt_base }}
    {% endif %}

  # optional guards
  min_presence_seconds: !input min_presence_seconds
  block_if_media_playing: !input block_if_media_playing

  # bedtime settings
  base_enable_bedtime_question: !input enable_bedtime_question
  weekend_bedtime_mode: !input weekend_bedtime_mode
  bedtime_assist_satellite: !input bedtime_assist_satellite
  bedtime_question_text: !input bedtime_question_text
  bedtime_help_script: !input bedtime_help_script
  bedtime_question_delay: !input bedtime_question_delay

  bedtime_llm_prompt_base: !input bedtime_llm_prompt
  weekend_bedtime_llm_prompt_override: !input weekend_bedtime_llm_prompt_override

  enable_bedtime_question: >-
    {% if not base_enable_bedtime_question %}
      false
    {% elif weekend_profile_active and (weekend_bedtime_mode | default('same_as_weekdays')) == 'disabled' %}
      false
    {% else %}
      true
    {% endif %}

  bedtime_llm_prompt: >-
    {% if weekend_profile_active
          and (weekend_bedtime_mode | default('same_as_weekdays')) == 'use_weekend_bedtime_prompt'
          and ((weekend_bedtime_llm_prompt_override | default('')) | trim) %}
      {{ weekend_bedtime_llm_prompt_override }}
    {% else %}
      {{ bedtime_llm_prompt_base }}
    {% endif %}

triggers:
  # First nag: presence goes from off → on
  - trigger: state
    id: presence_on
    entity_id: !input presence_sensors
    from: "off"
    to: "on"

  # Repeated nags: periodic tick, filtered by conditions below
  - trigger: time_pattern
    id: nag_tick
    minutes: "/5"

conditions:
  # Day-of-week gating (weekday selection + optional weekend behavior)
  - condition: template
    alias: "Allowed on this day"
    value_template: >
      {% if effective_day_key not in (run_days | default([])) %}
        false
      {% elif weekend_blocked %}
        false
      {% else %}
        true
      {% endif %}

  # Time window (supports windows that cross midnight)
  - condition: template
    alias: "Within active time window"
    value_template: >
      {% set start = today_at(effective_start_time) %}
      {% set end = today_at(effective_end_time) %}
      {% set now_ts = as_timestamp(now()) %}
      {% set start_ts = as_timestamp(start) %}
      {% set end_ts = as_timestamp(end) %}
      {% if end_ts > start_ts %}
        {{ now_ts >= start_ts and now_ts <= end_ts }}
      {% else %}
        {{ now_ts >= start_ts or now_ts <= end_ts }}
      {% endif %}

  # Optional: do not speak while media is actively playing
  - condition: template
    alias: "Not speaking over active media"
    value_template: >
      {% if not block_if_media_playing %}
        true
      {% else %}
        {{ states(player_entity | default('')) | default('idle') not in ['playing', 'buffering'] }}
      {% endif %}

  # Optional: require presence to be stable for at least N seconds
  - condition: template
    alias: "Minimum presence duration met"
    value_template: >
      {% set secs = (min_presence_seconds | default(0)) | int %}
      {% if secs <= 0 %}
        true
      {% else %}
        {% set on_sensors = expand(presence_entities) | selectattr('state', 'eq', 'on') | list %}
        {% if on_sensors | length == 0 %}
          false
        {% else %}
          {% set last_change = (on_sensors | map(attribute='last_changed') | min) %}
          {{ (as_timestamp(now()) - as_timestamp(last_change)) >= secs }}
        {% endif %}
      {% endif %}

  # Must still be present in the area
  - condition: template
    alias: "Presence still detected"
    value_template: >
      {{ expand(presence_entities) | selectattr('state', 'eq', 'on') | list | length > 0 }}

  # Only allow time_pattern-based runs when repeat_while_present = true
  - condition: template
    alias: "Trigger allowed by repeat mode"
    value_template: >
      {% if not repeat_while_present and trigger.id | default('') == 'nag_tick' %}
        false
      {% else %}
        true
      {% endif %}

  # Cooldown + max nags logic
  - condition: template
    alias: "Cooldown + max nags per session"
    value_template: >
      {% set mins = (cooldown | default(30)) | int %}
      {% set max_nags = (max_nags_per_session | default(0)) | int %}
      {% set last = this.attributes.last_triggered | default(none) %}
      {% set enough_time = last is none
        or (as_timestamp(now()) - as_timestamp(last | default(as_datetime('2000-01-01'), true)))
           > (mins * 60) %}
      {% if not enough_time %}
        false
      {% elif max_nags == 0 %}
        true
      {% else %}
        {% set on_sensors = expand(presence_entities)
          | selectattr('state', 'eq', 'on') | list %}
        {% if on_sensors | length == 0 %}
          true
        {% else %}
          {% set session_start = (on_sensors
              | map(attribute='last_changed') | min) %}
          {% set max_duration = max_nags * mins * 60 %}
          {{ (as_timestamp(now()) - as_timestamp(session_start)) < max_duration }}
        {% endif %}
      {% endif %}

actions:
  - alias: "Set action-local variables"
    variables:
      player: !input media_player
      tts_mode: !input tts_mode
      tts_entity: !input tts_entity
      area_name: !input area_name
      voice_profile: !input elevenlabs_voice_profile
      context_entities: !input context_entities

      tod_label: >-
        {% if enable_bedtime_question %}
          evening
        {% else %}
          {% set h = now().hour %}
          {% if 5 <= h < 12 %}
            morning
          {% elif 12 <= h < 18 %}
            afternoon
          {% else %}
            evening
          {% endif %}
        {% endif %}

      sensor_context: >-
        {% set entities = context_entities | default([]) %}
        {% if entities | length == 0 %}
          none
        {% else %}
          {% set expanded = expand(entities) %}
          {%- for e in expanded %}
          {% if e.domain == 'media_player' %}
          - {{ e.entity_id }} ({{ e.name }}): {{ e.state }}{% if e.state == 'playing' %} — "{{ e.attributes.media_title | default('unknown track') }}"{% if e.attributes.media_artist | default('') %} by {{ e.attributes.media_artist | default('') }}{% endif %}{% if e.attributes.media_content_type | default('') %} [{{ e.attributes.media_content_type | default('') }}]{% endif %}{% endif %}
          {% else %}
          - {{ e.entity_id }} ({{ e.name }}): {{ e.state }}{% if e.attributes.unit_of_measurement | default('') %} {{ e.attributes.unit_of_measurement | default('') }}{% endif %}
          {%- endif %}
          {%- endfor %}
        {% endif %}

  - alias: "Generate proactive message via LLM"
    continue_on_error: true
    action: conversation.process
    data:
      agent_id: !input conversation_agent
      text: >
        {{ llm_prompt }}

        context:
        - area: {{ area_name }}
        - time_of_day: {{ tod_label }}
        - trigger_type: {{ trigger.id | default(trigger.platform | default('unknown')) }}
        - current_time: {{ now().strftime('%Y-%m-%d %H:%M') }}
        - extra_entities:
        {{ sensor_context }}

        task:
        respond with ONE short, natural sentence you would say out loud to {{ chosen_llm_name }}
        in this situation. maximum 220 characters. do not include quotation marks
        or any surrounding formatting.
    response_variable: ai_result

  - alias: "Extract proactive message with fallback"
    variables:
      proactive_message: >-
        {% set resp = ai_result.response if ai_result is defined else none %}
        {% set name = chosen_direct_name %}
        {% set fallback %}
          {% if tod_label == 'morning' %}
            good {{ tod_label }} in the {{ area_name | default('room') }}, {{ name }}. want me to start your usual chaos... i mean, music?
          {% elif tod_label == 'afternoon' %}
            back in the {{ area_name | default('room') }}, huh {{ name }}? need me to resume your tunes or handle something for you?
          {% else %}
            it's {{ tod_label }} in the {{ area_name | default('room') }}, {{ name }}. i can play something relaxing or set the mood if you want.
          {% endif %}
        {% endset %}
        {% if resp is not none
              and resp.speech is defined
              and resp.speech.plain is defined
              and resp.speech.plain.speech is defined %}
          {% set txt = resp.speech.plain.speech | trim %}
          {% if not txt %}
            {{ fallback | trim }}
          {% else %}
            {{ txt }}
          {% endif %}
        {% else %}
          {{ fallback | trim }}
        {% endif %}

  - alias: "Speak proactive message via TTS"
    choose:
      - alias: "ElevenLabs custom TTS with voice profile"
        conditions:
          - condition: template
            value_template: "{{ tts_mode == 'elevenlabs_custom_service' }}"
        sequence:
          - alias: "ElevenLabs tts.speak with voice_profile"
            continue_on_error: true
            action: tts.speak
            target:
              entity_id: "{{ tts_entity | default('') }}"
            data:
              message: "{{ proactive_message }}"
              media_player_entity_id: "{{ player | default('') }}"
              options:
                voice_profile: "{{ voice_profile | default('') }}"

      - alias: "Standard TTS entity"
        conditions:
          - condition: template
            value_template: "{{ tts_mode == 'standard_tts_entity' }}"
        sequence:
          - alias: "Standard tts.speak"
            continue_on_error: true
            action: tts.speak
            target:
              entity_id: "{{ tts_entity | default('') }}"
            data:
              message: "{{ proactive_message }}"
              media_player_entity_id: "{{ player | default('') }}"

    default:
      - alias: "TTS mode not recognized — no speech output (check tts_mode input)"
        stop: "Unrecognized tts_mode: {{ tts_mode }}"
        error: false

  - alias: "Bedtime question flow (if enabled)"
    if:
      - condition: template
        value_template: "{{ enable_bedtime_question }}"
    then:
      - alias: "Wait for TTS audio to finish"
        delay:
          seconds: "{{ (bedtime_question_delay | default(5)) | int }}"

      - alias: "Generate bedtime question via LLM"
        continue_on_error: true
        action: conversation.process
        data:
          agent_id: !input conversation_agent
          text: >
            {{ bedtime_llm_prompt }}

            context:
            - area: {{ area_name }}
            - current_time: {{ now().strftime('%Y-%m-%d %H:%M') }}
            - extra_entities:
            {{ sensor_context }}

            task:
            respond with ONE short yes/no question to ask {{ chosen_llm_name }} about whether
            they want to go to bed now or start their bedtime routine.
            maximum 200 characters. do not include quotation marks.
        response_variable: bedtime_llm_result

      - alias: "Extract bedtime question with fallback"
        variables:
          final_bedtime_question: >-
            {% set resp = bedtime_llm_result.response if bedtime_llm_result is defined else none %}
            {% if resp is not none
                  and resp.speech is defined
                  and resp.speech.plain is defined
                  and resp.speech.plain.speech is defined %}
              {% set txt = resp.speech.plain.speech | trim %}
              {% if txt %}
                {{ txt }}
              {% else %}
                {{ bedtime_question_text | default('Do you want me to help you go to bed now?') }}
              {% endif %}
            {% else %}
              {{ bedtime_question_text | default('Do you want me to help you go to bed now?') }}
            {% endif %}

      # Service has built-in timeout; continue_on_error covers failures
      - alias: "Ask bedtime yes/no on Assist Satellite"
        continue_on_error: true
        action: assist_satellite.ask_question
        data:
          entity_id: "{{ bedtime_assist_satellite | default('') }}"
          question: "{{ final_bedtime_question }}"
          answers:
            - id: "yes"
              sentences:
                - "yes"
                - "yeah"
                - "sure"
                - "ok"
                - "okay"
                - "please"
            - id: "no"
              sentences:
                - "no"
                - "no thanks"
                - "not now"
                - "cancel"
        response_variable: bedtime_answer

      - alias: "Run bedtime script if user said yes"
        choose:
          - alias: "User answered YES and script is configured"
            conditions:
              - condition: template
                value_template: >
                  {{ bedtime_answer is defined
                     and (bedtime_answer.id | default('')) == 'yes'
                     and (bedtime_help_script | default('')) not in [none, ''] }}
            sequence:
              - alias: "Fire bedtime help script"
                action: script.turn_on
                target:
                  entity_id: "{{ bedtime_help_script }}"
