blueprint:
  name: "Bedtime routine Plus – LLM-driven goodnight (Kodi)"
  author: madalone
  description: '![Image](https://raw.githubusercontent.com/mmadalone/HA-Master-Repo/main/images/header/bedtime_routine_plus-header.jpeg)

    # Bedtime routine Plus – LLM-driven goodnight (Kodi)

    Fully LLM-orchestrated bedtime wind-down with Kodi media playback. The TV stays
    ON — Kodi plays movies, TV shows, or favourites selected via LLM conversation
    or preset configuration. Library pre-fetch injects the full Kodi catalog into
    the LLM context for intelligent content selection.

    Conversational modes (curated/freeform/both) use multi-turn satellite dialogue.
    Preset mode plays fixed content directly — no conversation, maximum efficiency.
    Sleepy TV detection skips content switching if bedtime media is already playing.

    All modes: kills lights (except living room lamp), countdown timer, bathroom
    occupancy guard, then final lamp-off. Optional TV sleep timer powers off the
    TV after a configurable delay.

    > **Looking for audiobook/Music Assistant playback?** See the companion
    *Bedtime Routine* blueprint (`bedtime_routine.yaml`).

    ### Recent changes

    - **v5.4.5:** Audit remediation — wrapped both bathroom guard blocks (preset +
    conversational) in config check so empty `bathroom_sensor` input skips the guard
    cleanly instead of evaluating `condition: state` against an empty entity_id (M-1, ×2),
    added explicit `| default('''')` on `states(countdown_helper)` in both `countdown_minutes`
    and `final_countdown` variables (L-1, ×2), added clarifying comment on intentional
    `trigger.id | default(''scheduled'')` in presence gate (L-2), documented intentional
    TTS voice-profile choose duplication ×6 as design decision (L-3).

    - **v5.4.4:** Audit remediation — added explicit parentheses on `states(eid) | default()`
    in all 4 sensor context builder templates to resolve Jinja2 operator precedence
    ambiguity (L-2, ×4), fixed bathroom guard alias from "remaining" to "full" grace
    period to match actual behavior (L-3, ×2), added `states[sensor] is defined` guard
    on presence gate `last_changed` access to prevent KeyError on missing entities (M-1),
    added parentheses on `presence_min_minutes | int(0)` in elapsed comparison.

    - **v5.4.3:** Audit remediation — removed `| default(0)` sentinel from
    countdown_minutes and final_countdown templates that caused 0-minute fallback
    instead of default_countdown when helper unavailable (M-1), added `| float(0)`
    safety on `as_timestamp()` comparisons in effective_day_key (L-1), added
    `| default(false)` guard on both `wait.completed` checks in bathroom guard (L-2).

    - **v5.4.2:** Audit remediation — added continue_on_error on all 12 tts.speak
    actions (H-1), added continue_on_error on speaker reset switch.turn_off/turn_on
    (M-1). TTS and speaker reset failures no longer abort the routine.

    - **v5.4.1:** Audit remediation — fixed Jinja2 scoping bug where curated_items
    list was always empty due to {% set %} inside {% for %} loop (C-1), fixed
    identical scoping bug on genre-filtered movies list (C-2), added
    continue_on_error on manual trigger boolean reset (M-2), added
    continue_on_error on all 8 logbook.log calls (L-1).

    - **v5.4.0:** Audit remediation — fixed TV sleep timer targeting Kodi instead
    of TV entity (C-1), fixed broken presence duration gate using wrong API for
    last_changed (C-2), added continue_on_error on 8 non-critical service calls
    (H-1), documented empty-entity trigger limitation on manual_trigger (H-2),
    added max_exceeded: silent (M-3),
    added blueprint_version variable, documented noon threshold in effective_day_key,
    fixed whitespace fallbacks in settling-in extraction.

    - **v5.3.3:** Fix collapsed sections — bare `default:` (null) on entity/time
    selectors prevents HA from honoring `collapsed: true`. Changed 11 inputs
    to `default: ""` across §①②③④⑨⑪.
    Time selectors use real defaults (23:00, 00:30) — empty string crashes `at:` triggers.

    - **v5.3.2:** Audit remediation — removed duplicate source_url key,
    collapsed: true on §①–② (all sections now collapsible), Kodi playback
    verification with logbook fallback in preset mode (AP-17), explicit
    continue_on_timeout on pre-fetch wait_for_trigger blocks (AP-04)

    - **v5.3.1:** Audit fixes — collapsed: true on §③–⑩, source_url added,
    continue_on_error on Kodi pre-fetch calls, response_type guard on
    conversational goodnight extraction

    - **v5.3.0:** Weekend overrides — run_days day-of-week gate, optional
    weekend profile with separate bedtime schedule, cross-midnight day
    attribution via effective_day_key. Manual triggers bypass all gates.
    Full port from proactive_llm_sensors.yaml weekend logic.

    - **v5.2.0:** Sleepy TV — added PVR channel detection method using REST sensor.
    New input: PVR channel sensor entity. Genres now optional when PVR detection active.'
  domain: automation
  source_url: https://github.com/mmadalone/HA-Master-Repo/blob/main/automation/bedtime_routine_plus.yaml
  homeassistant:
    min_version: "2024.10.0"
  input:
    # ===========================================================================
    # ① TRIGGER
    # ===========================================================================
    trigger_settings:
      name: "① Trigger"
      icon: mdi:play-circle-outline
      collapsed: false
      description: >
        How the bedtime routine starts. Enable scheduled, manual, or both.
      input:
        scheduled_time:
          name: Scheduled bedtime
          description: >
            Time to automatically trigger bedtime. Leave empty to disable
            the scheduled trigger.
          default: "23:00:00"
          selector:
            time: {}

        manual_trigger:
          name: Manual trigger boolean
          description: >
            An input_boolean entity exposed to voice assistants (e.g. Alexa).
            Toggling it ON triggers the bedtime routine. Leave empty to disable
            manual triggering. Note: HA instantiates the state trigger even when
            empty — this generates harmless log warnings on reload. No workaround
            exists for blueprint conditional triggers.
          default: ""
          selector:
            entity:
              domain: input_boolean

        presence_sensors:
          name: Presence sensors (optional)
          description: >
            One or more occupancy/presence/motion sensors. If ANY (default) or
            ALL report occupied for the minimum duration, the routine proceeds.
            Leave empty to disable the presence gate entirely — the routine
            always runs. Manual triggers bypass this gate regardless.
          default: []
          selector:
            entity:
              domain: binary_sensor
              device_class:
                - occupancy
                - presence
                - motion
              multiple: true

        presence_minimum_minutes:
          name: Minimum presence duration (minutes)
          description: >
            Minimum consecutive minutes a sensor must report occupied before
            the gate passes. Set to 0 to check current state only (is anyone
            there right now?). Higher values prevent false positives from
            someone walking through.
          default: 0
          selector:
            number:
              min: 0
              max: 300
              unit_of_measurement: minutes

        presence_require_all:
          name: Require ALL sensors
          description: >
            If enabled, ALL configured presence sensors must confirm presence.
            If disabled (default), ANY single sensor confirming presence is
            sufficient to pass the gate.
          default: false
          selector:
            boolean: {}

        run_days:
          name: Run on these days
          description: >
            Days of the week the scheduled trigger is allowed to fire. If
            today is not selected, the scheduled trigger is silently skipped.
            Manual triggers bypass this gate — you can always trigger
            bedtime by hand regardless of day.
          default:
            - mon
            - tue
            - wed
            - thu
            - fri
            - sat
            - sun
          selector:
            select:
              options:
                - label: "Monday"
                  value: mon
                - label: "Tuesday"
                  value: tue
                - label: "Wednesday"
                  value: wed
                - label: "Thursday"
                  value: thu
                - label: "Friday"
                  value: fri
                - label: "Saturday"
                  value: sat
                - label: "Sunday"
                  value: sun
              multiple: true

    # ===========================================================================
    # ② DEVICES
    # ===========================================================================
    devices:
      name: "② Devices"
      icon: mdi:television
      collapsed: true
      description: >
        TV, lights, and speaker switches involved in the bedtime flow. Note:
        the TV stays ON in this blueprint — Kodi needs the screen. Use the
        TV sleep timer (⑨) for delayed power-off.
      input:
        tv_entity:
          name: TV media player (optional)
          description: >
            The TV media_player entity for CEC control. Used by the TV sleep
            timer to power off after a delay. Leave empty if your TV doesn't
            support CEC or if you use an IR script instead.
          default: ""
          selector:
            entity:
              domain: media_player

        tv_off_script:
          name: TV off script (optional)
          description: >
            A script entity for TV shutdown — useful for IR sequences or
            multi-step power-off. Used by the TV sleep timer (not during the
            main routine — TV stays on for Kodi). Leave empty if not needed.
          default: ""
          selector:
            entity:
              domain: script

        lights_off_target:
          name: Lights to turn off
          description: >
            Lights or switches to kill immediately. Use area or label targeting
            to auto-include future devices. The living room lamp (below) is
            excluded separately — it stays on during the countdown.
          default: {}
          selector:
            target:
              entity:
                domain:
                  - light
                  - switch

        living_room_lamp:
          name: Living room lamp
          description: >
            The lamp that stays on during the countdown and is turned off last,
            after the bathroom guard clears. Can be a light or a switch (smart plug).
          default: ""
          selector:
            entity:
              domain:
                - light
                - switch

        reset_switches:
          name: Speaker reset switches (optional)
          description: >
            Switches to power-cycle before TTS (e.g. smart plugs on speakers).
            Leave empty if your speakers don't need a reset.
          default: {}
          selector:
            target:
              entity:
                domain: switch

        reset_switch_delay:
          name: Speaker reset delay
          description: >
            How long to wait between turning reset switches off and on.
          default: "0:00:02"
          selector:
            duration: {}

        media_players_stop:
          name: Media players to pause/stop (optional)
          description: >
            Additional media players to pause before lights-off — Chromecast,
            Sonos, Music Assistant players, etc. The Kodi entity is automatically
            excluded from this list — it stays playing. Leave empty if not needed.
          default: {}
          selector:
            target:
              entity:
                domain: media_player

    # ===========================================================================
    # ③ AI CONVERSATION
    # ===========================================================================
    conversation:
      name: "③ AI conversation"
      icon: mdi:robot-happy
      description: >
        Conversation agent, satellite, and bedtime announcement settings.
      collapsed: true
      input:
        conversation_agent:
          name: Conversation agent
          description: >
            Dedicated bedtime conversation agent. Its system prompt handles
            personality, permissions, and behavioral rules. The blueprint only
            sends dynamic per-run context.
          default: conversation.quark_extended_bedtime
          selector:
            conversation_agent:

        assist_satellites:
          name: Assist satellites
          description: >
            Voice PE / Assist satellites that deliver the bedtime conversation.
          default: {}
          selector:
            target:
              entity:
                domain: assist_satellite

        tts_engine:
          name: TTS engine
          description: >
            Text-to-speech engine for spoken messages (e.g. ElevenLabs, Piper).
          default: ""
          selector:
            entity:
              domain: tts

        voice_profile:
          name: TTS voice profile (optional)
          description: >
            ElevenLabs voice profile name. Leave empty for the engine default
            or if not using ElevenLabs.
          default: ""
          selector:
            text: {}

        default_countdown_minutes:
          name: Default countdown (minutes)
          description: >
            How many minutes before the lamp turns off. In conversational modes
            the LLM announces this and (if enabled) lets the user negotiate more
            time. In preset mode this is the fixed countdown — no negotiation.
          default: 4
          selector:
            number:
              min: 1
              max: 30
              unit_of_measurement: minutes

        enable_countdown_negotiation:
          name: Enable countdown negotiation
          description: >
            Allow the LLM to negotiate extra time with the user. If disabled,
            the default countdown is used without asking. Ignored in preset
            mode (negotiation is always off in preset).
          default: true
          selector:
            boolean: {}

        enable_media_offer:
          name: Enable bedtime media offer
          description: >
            Let the LLM offer bedtime content after the countdown announcement.
            If disabled, skips straight to goodnight. Ignored in preset mode
            (content always plays in preset).
          default: true
          selector:
            boolean: {}

        bedtime_prompt:
          name: Bedtime announcement prompt
          description: >
            Prompt sent to the conversation agent to generate the bedtime
            announcement. Available variables: {{ countdown_minutes }}.
            Used in all modes — preset and conversational.
          default: >
            It's bedtime. Lights out in {{ countdown_minutes }} minutes.
            Announce this and ask if the user wants more time.
            Keep it short — max 2 sentences.
          selector:
            text:
              multiline: true

        goodnight_prompt:
          name: Goodnight prompt (conversational modes)
          description: >
            Prompt for the final goodnight message in curated/freeform/both
            modes — fires after countdown and media decisions are settled.
            Not used in preset mode (use the contextual goodnight in ⑧ instead).
          default: >
            Say goodnight. Be warm but brief — one or two sentences max.
          selector:
            text:
              multiline: true

    # ===========================================================================
    # ④ KODI PLAYBACK
    # ===========================================================================
    kodi_playback:
      name: "④ Kodi playback"
      icon: mdi:kodi
      description: >
        Kodi entity, volume, content mode, and curated/preset content settings.
      collapsed: true
      input:
        kodi_entity:
          name: Kodi media player
          description: >
            The Kodi media_player entity for playback. This entity stays
            playing during the bedtime routine — the TV is NOT turned off.
          default: ""
          selector:
            entity:
              domain: media_player

        kodi_volume_target:
          name: Kodi volume target
          description: >
            Volume to set Kodi to at bedtime (0.0 to 1.0). Lowered for
            comfortable sleep-time viewing/listening.
          default: 0.15
          selector:
            number:
              min: 0.0
              max: 1.0
              step: 0.05

        bedtime_media_mode:
          name: Bedtime media mode
          description: >
            How bedtime content is selected on Kodi. Curated presents a
            pre-configured list. Freeform pre-fetches the Kodi library for
            LLM-driven selection. Both combines them. Preset plays fixed
            content directly — no conversation.
          default: curated
          selector:
            select:
              options:
                - label: "Curated list"
                  value: curated
                - label: "Freeform (LLM picks from library)"
                  value: freeform
                - label: "Both (curated + freeform fallback)"
                  value: both
                - label: "Preset (fixed content, no conversation)"
                  value: preset

        kodi_curated_content:
          name: Curated content list
          description: >
            Name=ContentID pairs, one per line. The name is shown to the user;
            the ContentID is passed to Kodi for playback. Supports file paths,
            special:// URIs, and plugin:// URIs.
            Example: Rain Sounds=special://profile/playlists/video/rain.xsp
          default: ""
          selector:
            text:
              multiline: true

        kodi_preset_content:
          name: Preset content ID
          description: >
            Content path or URI for preset mode. Can be a file path, special://
            URI, plugin:// URI, or smart playlist path. Played directly without
            conversation. Only used in preset mode.
          default: ""
          selector:
            text: {}

        kodi_media_content_type:
          name: Kodi media content type
          description: >
            How Kodi interprets the content ID for preset/direct playback.
            DIRECTORY for smart playlists (.xsp) and folders. video for direct
            files. CHANNEL for PVR channels.
          default: DIRECTORY
          selector:
            select:
              options:
                - label: "Directory (playlists, folders)"
                  value: DIRECTORY
                - label: "Video (direct file)"
                  value: video
                - label: "Channel (PVR)"
                  value: CHANNEL
                - label: "Music"
                  value: music

        kodi_tts_player:
          name: TTS audio player
          description: >
            The media_player entity where TTS audio plays — typically a bedroom
            speaker, NOT the TV. Keeps spoken announcements on a separate output
            from Kodi video playback.
          default: ""
          selector:
            entity:
              domain: media_player

        bedtime_media_post_play_delay:
          name: Post-play delay (seconds)
          description: >
            Seconds to wait after play_media before reading Kodi state. Lets
            Kodi update its attributes (media_title, etc.) before the blueprint
            checks what's playing.
          default: 3
          selector:
            number:
              min: 1
              max: 15
              unit_of_measurement: seconds

    # ===========================================================================
    # ⑤ SLEEPY TV DETECTION
    # ===========================================================================
    sleepytv:
      name: "⑤ Sleepy TV detection"
      icon: mdi:sleep
      description: >
        Detect if bedtime content is already playing on Kodi. If detected,
        skip content switching — just lower volume and proceed. Useful when
        the user has already started their bedtime playlist manually.
      collapsed: true
      input:
        sleepytv_detection_method:
          name: Detection method
          description: >
            How to detect if bedtime content is already playing. Title match
            checks media_title. Content ID match checks media_content_id.
            Combined requires both playing state AND title match.
          default: media_title_contains
          selector:
            select:
              options:
                - label: "Media title contains match string"
                  value: media_title_contains
                - label: "Content ID matches preset"
                  value: media_content_id_matches
                - label: "Playing + title contains match string"
                  value: state_playing_and_title
                - label: "PVR channel matches (REST sensor)"
                  value: pvr_channel_matches

        sleepytv_match_string:
          name: Match string
          description: >
            String to match against Kodi media_title (or content_id for the
            content_id method). E.g. "Rain Sounds", "Fireplace", "Nature".
            Leave empty to disable sleepy TV detection.
          default: ""
          selector:
            text: {}

        sleepytv_pvr_sensor:
          name: PVR channel sensor
          description: >
            REST sensor entity that reports the current PVR channel name.
            Only used when detection method is "PVR channel matches".
            Default: sensor.madteevee_pvr_channel
          default: sensor.madteevee_pvr_channel
          selector:
            entity:
              domain: sensor

    # ===========================================================================
    # ⑥ KODI LIBRARY & GENRE PREFERENCES
    # ===========================================================================
    kodi_library:
      name: "⑥ Kodi library & genre preferences"
      icon: mdi:movie-open
      description: >
        Library pre-fetch settings and genre filtering for freeform/both modes.
        The blueprint fetches your Kodi library via JSON-RPC and injects a
        filtered catalog into the LLM context for intelligent content selection.
      collapsed: true
      input:
        kodi_library_fetch_enabled:
          name: Enable library pre-fetch
          description: >
            Fetch Kodi library data via JSON-RPC for LLM content selection.
            Disable for curated-only or preset modes to skip the ~8 second
            pre-fetch overhead.
          default: true
          selector:
            boolean: {}

        kodi_library_fetch_timeout:
          name: Fetch timeout (seconds)
          description: >
            Timeout per JSON-RPC call. Increase if Kodi is slow to respond.
          default: 10
          selector:
            number:
              min: 5
              max: 30
              unit_of_measurement: seconds

        kodi_library_movies_limit:
          name: Max movies to fetch
          description: >
            Maximum number of movies to retrieve from the Kodi library. Higher
            values give the LLM more options but use more tokens.
          default: 50
          selector:
            number:
              min: 10
              max: 200

        kodi_library_shows_limit:
          name: Max in-progress shows
          description: >
            Maximum number of in-progress TV shows to retrieve. These are shows
            the user is currently watching — always offered first.
          default: 20
          selector:
            number:
              min: 5
              max: 50

        kodi_library_recent_limit:
          name: Max recently added episodes
          description: >
            Maximum number of recently added TV episodes to retrieve.
          default: 20
          selector:
            number:
              min: 5
              max: 100

        kodi_preferred_genres:
          name: Preferred bedtime genres
          description: >
            Comma-separated list of preferred genres for bedtime viewing.
            The LLM prioritizes content matching these genres. E.g.
            "Documentary, Comedy, Nature, Animation".
          default: ""
          selector:
            text: {}

        kodi_excluded_genres:
          name: Excluded genres
          description: >
            Comma-separated list of genres to exclude from bedtime suggestions.
            Movies matching these genres are filtered OUT before the LLM sees
            them. E.g. "Horror, Thriller, Crime". In-progress TV shows bypass
            this filter — continuations are always offered.
          default: ""
          selector:
            text: {}

        kodi_bedtime_mood:
          name: Bedtime mood descriptor
          description: >
            Freeform text describing the ideal bedtime viewing mood. Injected
            into the LLM prompt to guide content selection. E.g. "Relaxing,
            calming content suitable for falling asleep to."
          default: "Relaxing, calming content suitable for falling asleep to."
          selector:
            text:
              multiline: true

    # ===========================================================================
    # ⑦ SETTLING-IN TTS
    # ===========================================================================
    settling_tts:
      name: "⑦ Settling-in TTS"
      icon: mdi:weather-night
      description: >
        Optional contextual TTS announcement after bedtime content starts
        playing. The LLM receives sensor states for context — e.g. temperature,
        weather, humidity — and generates a brief settling-in message.
      collapsed: true
      input:
        enable_settling_tts:
          name: Enable settling-in TTS
          description: >
            Deliver a short contextual announcement after bedtime content starts.
          default: false
          selector:
            boolean: {}

        settling_prompt:
          name: Settling-in prompt
          description: >
            Prompt for the settling-in message. Sensor states are injected
            automatically — the agent sees them as context. Keep it brief.
          default: >
            The user is settling in for bed. Bedtime content is playing on the TV.
            Give a very brief, warm observation based on the sensor data
            provided. One sentence max.
          selector:
            text:
              multiline: true

        settling_sensors:
          name: Settling-in context sensors
          description: >
            Entities whose current state is injected into the LLM prompt for
            context. E.g. outdoor temperature, bedroom humidity, weather
            condition. The agent receives "entity_id: state" pairs.
          default: []
          selector:
            entity:
              multiple: true

    # ===========================================================================
    # ⑧ FINAL GOODNIGHT TTS
    # ===========================================================================
    goodnight_context_tts:
      name: "⑧ Final goodnight TTS"
      icon: mdi:moon-waning-crescent
      description: >
        Optional contextual goodnight announcement after the bathroom guard
        clears. The LLM receives sensor states and generates a final goodnight.
        In preset mode this replaces the simpler goodnight prompt in ③.
      collapsed: true
      input:
        enable_goodnight_tts:
          name: Enable final goodnight TTS
          description: >
            Deliver a contextual goodnight after the bathroom guard clears.
          default: false
          selector:
            boolean: {}

        goodnight_context_prompt:
          name: Final goodnight prompt
          description: >
            Prompt for the final goodnight message. Sensor states are injected
            automatically. This fires right before the lamp turns off.
          default: >
            The user is about to sleep. Lights are going off. Say goodnight
            with a brief, warm message informed by the sensor data. One or
            two sentences max.
          selector:
            text:
              multiline: true

        goodnight_sensors:
          name: Goodnight context sensors
          description: >
            Entities whose current state is injected into the LLM prompt for
            the final goodnight. Can differ from settling-in sensors — e.g.
            include tomorrow's weather forecast, alarm time, etc.
          default: []
          selector:
            entity:
              multiple: true

    # ===========================================================================
    # ⑨ BATHROOM GUARD & TIMING
    # ===========================================================================
    timing_and_guards:
      name: "⑨ Bathroom guard & timing"
      icon: mdi:timer-sand
      description: >
        Bathroom occupancy detection, grace periods, and cleanup timing.
      collapsed: true
      input:
        bathroom_sensor:
          name: Bathroom occupancy sensor
          description: >
            Binary sensor that detects bathroom occupancy. The lamp stays on
            while this sensor is occupied, with a grace period after it clears.
          default: ""
          selector:
            entity:
              domain: binary_sensor
              device_class: occupancy

        bathroom_grace_period:
          name: Bathroom grace period
          description: >
            How long to keep the lamp on after the bathroom sensor clears.
            Prevents lights-out while someone walks between bathroom and bedroom.
          default: "0:02:00"
          selector:
            duration: {}

        bathroom_max_timeout:
          name: Bathroom guard max timeout
          description: >
            Maximum time to wait for the bathroom to clear. After this, the lamp
            turns off regardless — can't wait forever.
          default: "0:10:00"
          selector:
            duration: {}

        countdown_helper:
          name: Countdown minutes helper
          description: >
            An input_number helper that the conversation agent uses to set
            the negotiated countdown duration (via an exposed script).
            Create one with min=1, max=30, step=1.
          default: ""
          selector:
            entity:
              domain: input_number

        temporary_switches:
          name: Temporary switches (optional)
          description: >
            Switches turned on during the bedtime flow and cleaned up at the end.
            E.g. a "bedtime_active" indicator boolean.
          default: {}
          selector:
            target:
              entity:
                domain:
                  - switch
                  - input_boolean

        post_tts_delay:
          name: Post-TTS delay (seconds)
          description: >
            Buffer after TTS speak actions to let streaming audio finish.
            ElevenLabs needs 5+ seconds; Piper may need less.
          default: 5
          selector:
            number:
              min: 1
              max: 15
              unit_of_measurement: seconds

    # ===========================================================================
    # ⑩ TV SLEEP TIMER
    # ===========================================================================
    tv_sleep_timer:
      name: "⑩ TV sleep timer"
      icon: mdi:television-off
      description: >
        Optional delayed TV power-off. Fires AFTER the main routine completes
        (after lamp off and cleanup). E.g. 4-min countdown + 60-min timer =
        TV off ~64 min after bedtime starts.
      collapsed: true
      input:
        tv_sleep_timer_enabled:
          name: Enable TV sleep timer
          description: >
            Automatically power off the TV after a delay. The timer starts
            after the main bedtime routine finishes (lamp off, cleanup done).
          default: false
          selector:
            boolean: {}

        tv_sleep_timer_minutes:
          name: Sleep timer duration (minutes)
          description: >
            How many minutes to wait before powering off the TV.
          default: 60
          selector:
            number:
              min: 1
              max: 300
              unit_of_measurement: minutes

        tv_sleep_timer_method:
          name: Sleep timer power-off method
          description: >
            How to power off the TV. CEC sends media_player.turn_off.
            Script fires a custom script entity (configured in ② Devices).
          default: cec
          selector:
            select:
              options:
                - label: "CEC (media_player.turn_off)"
                  value: cec
                - label: "Script (custom power-off script)"
                  value: script

    # ===========================================================================
    # ⑪ WEEKEND OVERRIDES
    # ===========================================================================
    weekend_overrides:
      name: "⑪ Weekend overrides"
      icon: mdi:weather-sunny
      description: >
        Optional weekend-specific schedule. Only applies when Weekend
        behavior is set to "use_weekend_profile".
      collapsed: true
      input:
        weekend_mode:
          name: Weekend behavior
          description: >
            Choose what happens on "weekend" days (as defined below).
          default: same_as_weekdays
          selector:
            select:
              options:
                - label: "Same as weekdays"
                  value: same_as_weekdays
                - label: "Disabled on weekends"
                  value: disabled_on_weekends
                - label: "Use weekend profile"
                  value: use_weekend_profile

        weekend_days:
          name: Weekend days
          description: >
            Which days count as "weekend" for the setting above. Uses
            cross-midnight attribution — if your weekend bedtime fires
            at 01:00 Sunday, that counts as Saturday night. Select the
            calendar days your weekend nights START on.
          default:
            - sat
            - sun
          selector:
            select:
              options:
                - label: "Monday"
                  value: mon
                - label: "Tuesday"
                  value: tue
                - label: "Wednesday"
                  value: wed
                - label: "Thursday"
                  value: thu
                - label: "Friday"
                  value: fri
                - label: "Saturday"
                  value: sat
                - label: "Sunday"
                  value: sun
              multiple: true

        weekend_scheduled_time:
          name: Weekend scheduled bedtime
          description: >
            Separate bedtime trigger for weekend days when using the
            weekend profile. Can differ from the weekday schedule —
            e.g. 01:00 for late weekend nights. Leave empty to disable
            the weekend time trigger.
          default: "00:30:00"
          selector:
            time: {}

# ═══════════════════════════════════════════════════════════════════════
# Variables
# ═══════════════════════════════════════════════════════════════════════
variables:
  # --- Blueprint version ---
  blueprint_version: "5.4.5"

  # --- Trigger inputs ---
  scheduled_time_val: !input scheduled_time
  manual_trigger_val: !input manual_trigger

  # --- Presence gate inputs ---
  presence_sensors_val: !input presence_sensors
  presence_min_minutes: !input presence_minimum_minutes
  presence_require_all_val: !input presence_require_all
  presence_gate_passed: >-
    {% set sensors = presence_sensors_val | default([]) %}
    {% if sensors | length == 0 %}
      true
    {% else %}
      {% set ns = namespace(results=[]) %}
      {% for sensor in sensors %}
        {% set s = states(sensor) | default('unavailable') %}
        {% if s in ['unavailable', 'unknown'] %}
          {% set ns.results = ns.results + [true] %}
        {% elif s == 'on' %}
          {% if presence_min_minutes | int(0) == 0 %}
            {% set ns.results = ns.results + [true] %}
          {% else %}
            {% if states[sensor] is defined %}
              {% set changed = states[sensor].last_changed | default(none) %}
              {% if changed is none %}
                {% set ns.results = ns.results + [true] %}
              {% else %}
                {% set elapsed = (now() - as_datetime(changed)).total_seconds() / 60 %}
                {% set ns.results = ns.results + [(elapsed >= (presence_min_minutes | int(0)))] %}
              {% endif %}
            {% else %}
              {# Entity missing from state machine — treat as passed #}
              {% set ns.results = ns.results + [true] %}
            {% endif %}
          {% endif %}
        {% else %}
          {% set ns.results = ns.results + [false] %}
        {% endif %}
      {% endfor %}
      {% if presence_require_all_val %}
        {{ ns.results | reject('eq', true) | list | length == 0 }}
      {% else %}
        {{ ns.results | select('eq', true) | list | length > 0 }}
      {% endif %}
    {% endif %}

  # --- Day-of-week + weekend gate ---
  run_days: !input run_days
  weekend_mode: !input weekend_mode
  weekend_days: !input weekend_days
  weekend_scheduled_time_val: !input weekend_scheduled_time

  today_key: >-
    {% set days = ['mon','tue','wed','thu','fri','sat','sun'] %}
    {{ days[now().weekday()] }}

  trigger_scheduled_time: >-
    {% if trigger.id | default('') == 'scheduled_weekend' %}
      {{ weekend_scheduled_time_val | default('01:00:00') }}
    {% else %}
      {{ scheduled_time_val | default('23:00:00') }}
    {% endif %}

  effective_day_key: >-
    {# Cross-midnight day attribution: scheduled times before noon belong
       to the previous calendar day (e.g. 01:00 Sunday = Saturday night).
       Noon is the cutoff — bedtime routines never fire between 12:00–17:59. #}
    {% set days = ['mon','tue','wed','thu','fri','sat','sun'] %}
    {% set sched_ts = today_at(trigger_scheduled_time) %}
    {% set noon = today_at('12:00:00') %}
    {% if (as_timestamp(sched_ts) | float(0)) < (as_timestamp(noon) | float(0)) %}
      {{ days[(now().weekday() - 1) % 7] }}
    {% else %}
      {{ days[now().weekday()] }}
    {% endif %}

  is_weekend: >-
    {{ effective_day_key in (weekend_days | default([])) }}

  weekend_profile_active: >-
    {{ is_weekend and (weekend_mode | default('same_as_weekdays')) == 'use_weekend_profile' }}

  weekend_blocked: >-
    {{ is_weekend and (weekend_mode | default('same_as_weekdays')) == 'disabled_on_weekends' }}

  # --- Device inputs ---
  tv_entity: !input tv_entity
  tv_off_script: !input tv_off_script
  living_room_lamp: !input living_room_lamp
  reset_switches_val: !input reset_switches
  media_players_stop_val: !input media_players_stop

  # --- Conversation inputs ---
  conversation_agent: !input conversation_agent
  tts_engine_entity: !input tts_engine
  voice_profile_val: !input voice_profile
  default_countdown: !input default_countdown_minutes
  enable_negotiation: !input enable_countdown_negotiation
  enable_media: !input enable_media_offer
  bedtime_prompt_tpl: !input bedtime_prompt
  goodnight_prompt_tpl: !input goodnight_prompt

  # --- Kodi playback inputs ---
  kodi_entity: !input kodi_entity
  kodi_volume: !input kodi_volume_target
  bedtime_media_mode: !input bedtime_media_mode
  kodi_curated_text: !input kodi_curated_content
  kodi_preset_content_id: !input kodi_preset_content
  kodi_content_type: !input kodi_media_content_type
  kodi_tts_player: !input kodi_tts_player
  post_play_delay: !input bedtime_media_post_play_delay

  # --- Sleepy TV inputs ---
  sleepytv_detection: !input sleepytv_detection_method
  sleepytv_match: !input sleepytv_match_string
  sleepytv_pvr_entity: !input sleepytv_pvr_sensor

  # --- Library inputs ---
  library_fetch_enabled: !input kodi_library_fetch_enabled
  library_fetch_timeout: !input kodi_library_fetch_timeout
  movies_limit: !input kodi_library_movies_limit
  shows_limit: !input kodi_library_shows_limit
  recent_limit: !input kodi_library_recent_limit
  kodi_preferred_genres: !input kodi_preferred_genres
  kodi_excluded_genres: !input kodi_excluded_genres
  kodi_bedtime_mood: !input kodi_bedtime_mood

  # --- Timing inputs ---
  bathroom_sensor: !input bathroom_sensor
  countdown_helper: !input countdown_helper
  post_tts_delay_val: !input post_tts_delay

  # --- Settling-in TTS inputs ---
  enable_settling: !input enable_settling_tts
  settling_prompt_tpl: !input settling_prompt
  settling_sensor_list: !input settling_sensors

  # --- Final goodnight TTS inputs ---
  enable_gn_context: !input enable_goodnight_tts
  gn_context_prompt_tpl: !input goodnight_context_prompt
  gn_sensor_list: !input goodnight_sensors

  # --- TV sleep timer inputs ---
  sleep_timer_enabled: !input tv_sleep_timer_enabled
  sleep_timer_minutes: !input tv_sleep_timer_minutes
  sleep_timer_method: !input tv_sleep_timer_method

  # --- Derived ---
  is_preset_mode: "{{ bedtime_media_mode == 'preset' }}"
  countdown_minutes: >-
    {{ (states(countdown_helper) | default('')) | int(default_countdown) }}
  kodi_safe_content_type: >-
    {% set cid = kodi_preset_content_id | default('') %}
    {% if kodi_content_type == 'CHANNEL' and ('://' in cid or '/' in cid) %}
      video
    {% else %}
      {{ kodi_content_type }}
    {% endif %}

  # --- Sleepy TV detection template ---
  is_sleepytv_active: >-
    {% set match = sleepytv_match | default('') | string %}
    {% if match | length == 0 %}
      false
    {% else %}
      {% set kodi_state = states(kodi_entity) | default('unknown') %}
      {% set kodi_title = state_attr(kodi_entity, 'media_title') | default('') %}
      {% set kodi_content_id = state_attr(kodi_entity, 'media_content_id') | default('') %}
      {% if sleepytv_detection == 'media_title_contains' %}
        {{ match in kodi_title }}
      {% elif sleepytv_detection == 'media_content_id_matches' %}
        {{ kodi_content_id == kodi_preset_content_id }}
      {% elif sleepytv_detection == 'state_playing_and_title' %}
        {{ kodi_state == 'playing' and match in kodi_title }}
      {% elif sleepytv_detection == 'pvr_channel_matches' %}
        {% set pvr_ch = states(sleepytv_pvr_entity) | default('') %}
        {{ pvr_ch not in ['off', 'not_pvr', 'unknown', 'unavailable', '']
           and match | lower in pvr_ch | lower }}
      {% else %}
        false
      {% endif %}
    {% endif %}

  # --- Kodi auto-context injection template ---
  kodi_now_playing: >-
    {% set series = state_attr(kodi_entity, 'media_series_title') | default('') %}
    {% set title = state_attr(kodi_entity, 'media_title') | default('nothing') %}
    {% set season = state_attr(kodi_entity, 'media_season') | default('') %}
    {% set episode = state_attr(kodi_entity, 'media_episode') | default('') %}
    {% set content_type = state_attr(kodi_entity, 'media_content_type') | default('unknown') %}
    {% if series %}
      {{ series }} S{{ season }}E{{ episode }} "{{ title }}"
    {% else %}
      {{ title }} ({{ content_type }})
    {% endif %}

# ═══════════════════════════════════════════════════════════════════════
# Triggers
# ═══════════════════════════════════════════════════════════════════════
triggers:
  - alias: "Scheduled bedtime trigger"
    trigger: time
    at: !input scheduled_time
    id: scheduled

  - alias: "Manual trigger — input_boolean toggled on"
    trigger: state
    entity_id: !input manual_trigger
    to: "on"
    id: manual

  - alias: "Weekend scheduled bedtime trigger"
    trigger: time
    at: !input weekend_scheduled_time
    id: scheduled_weekend

conditions:
  - condition: template
    alias: "Allowed on this day (manual trigger bypasses)"
    value_template: >
      {% if trigger.id | default('') == 'manual' %}
        true
      {% elif weekend_blocked %}
        false
      {% elif trigger.id | default('') == 'scheduled_weekend' and not weekend_profile_active %}
        false
      {% elif trigger.id | default('') == 'scheduled' and weekend_profile_active %}
        false
      {% else %}
        {{ effective_day_key in (run_days | default([])) }}
      {% endif %}

# ═══════════════════════════════════════════════════════════════════════
# Actions
# ═══════════════════════════════════════════════════════════════════════
actions:
  # --- Common preamble (all modes) --------------------------------------------

  - alias: "Auto-reset manual trigger boolean — must happen before any condition can abort"
    choose:
      - alias: "Manual trigger was used — reset the boolean"
        conditions:
          - condition: trigger
            id: manual
        sequence:
          - alias: "Turn off the manual trigger boolean"
            continue_on_error: true
            action: input_boolean.turn_off
            target:
              entity_id: !input manual_trigger

  - alias: "Presence gate — abort if configured sensors show nobody present (manual trigger bypasses)"
    choose:
      - alias: "Presence gate active and failed — nobody home, abort routine"
        conditions:
          - condition: template
            alias: "Trigger is scheduled (manual bypasses gate)"
            # NOTE: default('scheduled') is intentional here — differs from default('')
            # elsewhere. If trigger.id is missing/undefined, we want the presence gate
            # to APPLY (treat as scheduled), not be bypassed (treat as manual).
            value_template: "{{ trigger.id | default('scheduled') == 'scheduled' }}"
          - condition: template
            alias: "Presence sensors are configured"
            value_template: "{{ presence_sensors_val | default([]) | length > 0 }}"
          - condition: template
            alias: "Presence gate did not pass"
            value_template: "{{ not (presence_gate_passed | bool(true)) }}"
        sequence:
          - alias: "Log presence gate failure — routine skipped"
            continue_on_error: true
            action: logbook.log
            data:
              name: "Bedtime Routine Plus"
              message: >-
                Presence gate: no presence detected. Routine skipped.
                Sensors: {{ presence_sensors_val | join(', ') }}.
                Mode: {{ 'require ALL' if presence_require_all_val else 'require ANY' }}.
                Min duration: {{ presence_min_minutes }} min.

          - alias: "Cleanup — turn off temporary switches before aborting"
            action: homeassistant.turn_off
            target: !input temporary_switches

          - stop: "Presence gate failed — nobody detected, routine aborted."

  - alias: "Initialize countdown helper to default minutes — agent may override via exposed script"
    continue_on_error: true
    action: input_number.set_value
    target:
      entity_id: !input countdown_helper
    data:
      value: "{{ default_countdown }}"

  - alias: "Activate temporary switches — bedtime_active indicator, etc."
    continue_on_error: true
    action: homeassistant.turn_on
    target: !input temporary_switches

  - alias: "Reset speakers — power-cycle to clear stale connections (skipped if no switches configured)"
    choose:
      - alias: "Reset switches are configured — power-cycle them"
        conditions:
          - condition: template
            value_template: >-
              {{ reset_switches_val is mapping
                 and (reset_switches_val.get('entity_id', []) | length > 0
                      or reset_switches_val.get('area_id', []) | length > 0
                      or reset_switches_val.get('label_id', []) | length > 0) }}
        sequence:
          - alias: "Power off reset switches"
            continue_on_error: true
            action: switch.turn_off
            target: !input reset_switches

          - alias: "Wait for speaker hardware to discharge"
            delay: !input reset_switch_delay

          - alias: "Power on reset switches"
            continue_on_error: true
            action: switch.turn_on
            target: !input reset_switches

          - alias: "Wait for speakers to boot and become available"
            delay:
              seconds: 3

  # --- LLM bedtime announcement (all modes) -----------------------------------

  - alias: "Generate bedtime announcement via conversation agent"
    continue_on_error: true
    action: conversation.process
    response_variable: bedtime_response
    data:
      agent_id: "{{ conversation_agent }}"
      text: >-
        {{ bedtime_prompt_tpl }}
        {% if not enable_negotiation or is_preset_mode %}
        IMPORTANT: Do NOT ask if the user wants more time. Countdown is fixed at {{ default_countdown }} minutes — just announce bedtime.
        {% endif %}

  - alias: "Extract bedtime announcement with defensive fallback"
    variables:
      bedtime_message: >-
        {% if bedtime_response is defined
           and bedtime_response.response is defined
           and bedtime_response.response.response_type | default('') != 'error'
           and bedtime_response.response.speech is defined %}
          {{ bedtime_response.response.speech.plain.speech
             | default("Time for bed. Lights out in " ~ default_countdown ~ " minutes.") }}
        {% else %}
          Time for bed. Lights out in {{ default_countdown }} minutes.
        {% endif %}

  - alias: "Deliver bedtime announcement — negotiation branch or one-shot TTS"
    choose:
      - alias: "Countdown negotiation enabled AND not preset mode — start interactive conversation"
        conditions:
          - condition: template
            value_template: "{{ enable_negotiation and not is_preset_mode }}"
        sequence:
          - alias: "Start conversation on satellites — agent can negotiate countdown"
            continue_on_error: true
            action: assist_satellite.start_conversation
            target: !input assist_satellites
            data:
              preannounce: true
              start_message: "{{ bedtime_message }}"
              extra_system_prompt: >-
                Bedtime routine active. Default countdown: {{ default_countdown }} minutes.
                The user may ask for more time. Use the voice_set_bedtime_countdown tool
                to change the countdown (min 1, max 15 minutes). Current lamp entity:
                {{ living_room_lamp }}. Bathroom sensor: {{ bathroom_sensor }}.

          - alias: "Wait for conversation to settle — agent has had time to set the countdown helper"
            delay:
              seconds: "{{ post_tts_delay_val }}"

    default:
      # NOTE: The TTS voice-profile choose pattern (check voice_profile_val →
      # speak with options → default: speak without) is repeated ×6 across this
      # blueprint. This is INTENTIONAL — blueprint YAML has no subroutine
      # mechanism, and extracting to a script would add latency + failure points
      # for every TTS call. Duplication is the lesser cost here. If the TTS
      # delivery pattern ever changes, grep for "voice_profile_val" to find
      # all instances. — v5.4.5 audit note
      - alias: "Negotiation disabled or preset mode — one-shot TTS announcement"
        choose:
          - alias: "TTS with voice profile (ElevenLabs)"
            conditions:
              - condition: template
                value_template: "{{ voice_profile_val | default('') | string | length > 0 }}"
            sequence:
              - alias: "Speak bedtime announcement with custom voice profile"
                continue_on_error: true
                action: tts.speak
                target:
                  entity_id: "{{ tts_engine_entity }}"
                data:
                  media_player_entity_id: "{{ kodi_tts_player }}"
                  message: "{{ bedtime_message }}"
                  options:
                    voice_profile: "{{ voice_profile_val }}"
        default:
          - alias: "Speak bedtime announcement with default TTS voice"
            continue_on_error: true
            action: tts.speak
            target:
              entity_id: "{{ tts_engine_entity }}"
            data:
              media_player_entity_id: "{{ kodi_tts_player }}"
              message: "{{ bedtime_message }}"

      - alias: "Post-TTS buffer — let streaming audio finish"
        delay:
          seconds: "{{ post_tts_delay_val }}"

  # --- Lights off except lamp (TV stays ON) -----------------------------------

  - alias: "Turn off targeted lights/switches — lamp stays on for the countdown"
    continue_on_error: true
    action: homeassistant.turn_off
    target: !input lights_off_target

  - alias: "Ensure the living room lamp is ON — nightlight during the countdown"
    continue_on_error: true
    action: homeassistant.turn_on
    target:
      entity_id: "{{ living_room_lamp }}"

  # --- Stop OTHER media players — Kodi excluded --------------------------------

  - alias: "Pause additional media players — Kodi excluded (skipped if none configured)"
    choose:
      - alias: "Media players are configured — attempt pause then fallback stop"
        conditions:
          - condition: template
            value_template: >-
              {{ media_players_stop_val is mapping
                 and (media_players_stop_val.get('entity_id', []) | length > 0
                      or media_players_stop_val.get('area_id', []) | length > 0
                      or media_players_stop_val.get('label_id', []) | length > 0) }}
        sequence:
          - alias: "Attempt pause on non-Kodi media players"
            continue_on_error: true
            action: media_player.media_pause
            target: !input media_players_stop

          - alias: "Fallback stop — catches players where pause failed"
            continue_on_error: true
            action: media_player.media_stop
            target: !input media_players_stop

  # --- Set Kodi volume to bedtime level ---------------------------------------

  - alias: "Lower Kodi volume to bedtime target"
    continue_on_error: true
    action: media_player.volume_set
    target:
      entity_id: "{{ kodi_entity }}"
    data:
      volume_level: "{{ kodi_volume }}"

  # --- Mode branch — preset vs conversational ---------------------------------

  - alias: "Mode branch — preset vs conversational bedtime media"
    choose:
      # =====================================================================
      # PRESET MODE — direct play, no LLM media conversation
      # =====================================================================
      - alias: "Preset mode — streamlined flow with direct Kodi play"
        conditions:
          - condition: template
            value_template: "{{ is_preset_mode }}"
        sequence:
          # --- Sleepy TV check — skip content switch if already playing ---
          - alias: "Sleepy TV gate — check if bedtime content is already playing"
            choose:
              - alias: "Bedtime content detected — skip content switch, just lower volume"
                conditions:
                  - condition: template
                    value_template: "{{ is_sleepytv_active }}"
                sequence:
                  - alias: "Log sleepy TV detection — content already playing"
                    continue_on_error: true
                    action: logbook.log
                    data:
                      name: "Bedtime Routine Plus"
                      message: >-
                        Sleepy TV detected: {{ kodi_now_playing }}. Skipping content switch.

            default:
              # --- Not already playing — start preset content ---
              - alias: "Play preset content on Kodi via play_media"
                action: media_player.play_media
                target:
                  entity_id: "{{ kodi_entity }}"
                data:
                  media_content_id: "{{ kodi_preset_content_id }}"
                  media_content_type: "{{ kodi_safe_content_type }}"
                continue_on_error: true

              - alias: "Post-play delay — let Kodi update attributes"
                delay:
                  seconds: "{{ post_play_delay | int(3) }}"

              - alias: "Verify Kodi playback started — log if play_media failed silently"
                if:
                  - condition: template
                    value_template: >-
                      {{ states(kodi_entity) | default('unknown')
                         not in ['playing', 'paused', 'buffering'] }}
                then:
                  - alias: "Log preset play_media failure — content may not have started"
                    continue_on_error: true
                    action: logbook.log
                    data:
                      name: "Bedtime Routine Plus"
                      message: >-
                        Preset play_media may have failed — Kodi state is
                        {{ states(kodi_entity) | default('unknown') }} after play
                        attempt. Content ID: {{ kodi_preset_content_id }}.

          # --- Optional settling-in contextual TTS ---
          - alias: "Settling-in TTS — optional contextual announcement after content starts"
            choose:
              - alias: "Settling-in TTS is enabled — generate and deliver"
                conditions:
                  - condition: template
                    value_template: "{{ enable_settling }}"
                sequence:
                  - alias: "Build sensor context string for settling-in prompt"
                    variables:
                      settling_sensor_context: >-
                        {% set ns = namespace(lines=[]) %}
                        {% for eid in settling_sensor_list %}
                          {% set ns.lines = ns.lines + [eid ~ ': ' ~ (states(eid) | default('unknown'))] %}
                        {% endfor %}
                        {{ ns.lines | join('\n') }}

                  - alias: "Generate settling-in message via conversation agent with sensor context"
                    continue_on_error: true
                    action: conversation.process
                    response_variable: settling_response
                    data:
                      agent_id: "{{ conversation_agent }}"
                      text: >-
                        {{ settling_prompt_tpl }}

                        Kodi is currently playing: {{ kodi_now_playing }}.

                        Current sensor readings:
                        {{ settling_sensor_context }}

                  - alias: "Extract settling-in message with defensive fallback"
                    variables:
                      settling_message: >-
                        {% if settling_response is defined
                           and settling_response.response is defined
                           and settling_response.response.response_type | default('') != 'error'
                           and settling_response.response.speech is defined %}
                          {{ settling_response.response.speech.plain.speech
                             | default('') }}
                        {% else %}
                          {{ '' }}
                        {% endif %}

                  - alias: "Deliver settling-in TTS if agent produced a message"
                    choose:
                      - alias: "Agent returned a non-empty settling message — speak it"
                        conditions:
                          - condition: template
                            value_template: "{{ settling_message | default('') | trim | length > 0 }}"
                        sequence:
                          - alias: "Speak settling-in message via TTS"
                            choose:
                              - alias: "TTS with voice profile (ElevenLabs)"
                                conditions:
                                  - condition: template
                                    value_template: "{{ voice_profile_val | default('') | string | length > 0 }}"
                                sequence:
                                  - alias: "Speak settling-in with custom voice profile"
                                    continue_on_error: true
                                    action: tts.speak
                                    target:
                                      entity_id: "{{ tts_engine_entity }}"
                                    data:
                                      media_player_entity_id: "{{ kodi_tts_player }}"
                                      message: "{{ settling_message }}"
                                      options:
                                        voice_profile: "{{ voice_profile_val }}"
                            default:
                              - alias: "Speak settling-in with default TTS voice"
                                continue_on_error: true
                                action: tts.speak
                                target:
                                  entity_id: "{{ tts_engine_entity }}"
                                data:
                                  media_player_entity_id: "{{ kodi_tts_player }}"
                                  message: "{{ settling_message }}"

                          - alias: "Post-TTS buffer for settling-in message"
                            delay:
                              seconds: "{{ post_tts_delay_val }}"

          # --- Countdown (non-negotiable in preset mode) ---
          - alias: "Wait the default countdown — lamp stays on, user settles in"
            delay:
              minutes: "{{ default_countdown }}"

          # --- Bathroom guard (preset mode) ---
          - alias: "Bathroom guard — check occupancy if sensor configured"
            choose:
              - alias: "No bathroom sensor configured — skip guard entirely"
                conditions:
                  - condition: template
                    value_template: "{{ (bathroom_sensor | default('')) | length == 0 }}"
                sequence: []
              - alias: "Bathroom occupied — wait for it to clear before turning off lamp"
                conditions:
                  - condition: state
                    entity_id: !input bathroom_sensor
                    state: "on"
                sequence:
                  - alias: "Wait for bathroom sensor to clear — max timeout prevents infinite wait"
                    wait_for_trigger:
                      - trigger: state
                        entity_id: !input bathroom_sensor
                        to: "off"
                    timeout: !input bathroom_max_timeout
                    continue_on_timeout: true

                  - alias: "Handle bathroom guard timeout — lights off regardless"
                    if:
                      - condition: template
                        value_template: "{{ not (wait.completed | default(false)) }}"
                    then:
                      - alias: "Bathroom guard timed out — proceeding with lamp off anyway"
                        continue_on_error: true
                        action: logbook.log
                        data:
                          name: "Bedtime Routine Plus"
                          message: >-
                            Bathroom guard timed out after max wait. Turning off lamp regardless.
                    else:
                      - alias: "Bathroom cleared — grace period before turning off lamp"
                        delay: !input bathroom_grace_period

            default:
              - alias: "Bathroom not occupied — check it's been clear long enough"
                choose:
                  - alias: "Bathroom was recently occupied — enforce grace period"
                    conditions:
                      - condition: state
                        entity_id: !input bathroom_sensor
                        state: "off"
                        for: !input bathroom_grace_period
                    sequence:
                      - alias: "Grace period already satisfied — proceed to lamp off"
                        continue_on_error: true
                        action: logbook.log
                        data:
                          name: "Bedtime Routine Plus"
                          message: "Bathroom clear and grace period satisfied. Turning off lamp."
                default:
                  - alias: "Bathroom recently cleared — wait full grace period as safety margin"
                    delay: !input bathroom_grace_period

          # --- Optional final goodnight contextual TTS (preset mode) ---
          - alias: "Final goodnight TTS — optional contextual announcement after bathroom clears"
            choose:
              - alias: "Final goodnight TTS is enabled — generate and deliver"
                conditions:
                  - condition: template
                    value_template: "{{ enable_gn_context }}"
                sequence:
                  - alias: "Build sensor context string for goodnight prompt"
                    variables:
                      gn_sensor_context: >-
                        {% set ns = namespace(lines=[]) %}
                        {% for eid in gn_sensor_list %}
                          {% set ns.lines = ns.lines + [eid ~ ': ' ~ (states(eid) | default('unknown'))] %}
                        {% endfor %}
                        {{ ns.lines | join('\n') }}

                  - alias: "Generate final goodnight via conversation agent with sensor context"
                    continue_on_error: true
                    action: conversation.process
                    response_variable: gn_context_response
                    data:
                      agent_id: "{{ conversation_agent }}"
                      text: >-
                        {{ gn_context_prompt_tpl }}

                        Kodi is playing: {{ kodi_now_playing }}.

                        Current sensor readings:
                        {{ gn_sensor_context }}

                  - alias: "Extract goodnight context message with defensive fallback"
                    variables:
                      gn_context_message: >-
                        {% if gn_context_response is defined
                           and gn_context_response.response is defined
                           and gn_context_response.response.response_type | default('') != 'error'
                           and gn_context_response.response.speech is defined %}
                          {{ gn_context_response.response.speech.plain.speech
                             | default('Goodnight. Sleep well.') }}
                        {% else %}
                          Goodnight. Sleep well.
                        {% endif %}

                  - alias: "Deliver final goodnight via TTS"
                    choose:
                      - alias: "TTS with voice profile (ElevenLabs)"
                        conditions:
                          - condition: template
                            value_template: "{{ voice_profile_val | default('') | string | length > 0 }}"
                        sequence:
                          - alias: "Speak goodnight with custom voice profile"
                            continue_on_error: true
                            action: tts.speak
                            target:
                              entity_id: "{{ tts_engine_entity }}"
                            data:
                              media_player_entity_id: "{{ kodi_tts_player }}"
                              message: "{{ gn_context_message }}"
                              options:
                                voice_profile: "{{ voice_profile_val }}"
                    default:
                      - alias: "Speak goodnight with default TTS voice"
                        continue_on_error: true
                        action: tts.speak
                        target:
                          entity_id: "{{ tts_engine_entity }}"
                        data:
                          media_player_entity_id: "{{ kodi_tts_player }}"
                          message: "{{ gn_context_message }}"

                  - alias: "Post-TTS buffer for final goodnight"
                    delay:
                      seconds: "{{ post_tts_delay_val }}"

    # =====================================================================
    # CONVERSATIONAL MODES — curated / freeform / both
    # =====================================================================
    default:
      # --- Re-read countdown — agent may have changed it ---
      - alias: "Re-read countdown helper — the agent may have negotiated a different value"
        variables:
          final_countdown: >-
            {{ (states(countdown_helper) | default('')) | int(default_countdown) }}

      # --- Sleepy TV check — skip media offer if already playing ---
      - alias: "Sleepy TV gate — check if bedtime content is already playing"
        choose:
          - alias: "Bedtime content detected — skip media conversation"
            conditions:
              - condition: template
                value_template: "{{ is_sleepytv_active }}"
            sequence:
              - alias: "Log sleepy TV detection — content already playing, skipping media offer"
                continue_on_error: true
                action: logbook.log
                data:
                  name: "Bedtime Routine Plus"
                  message: >-
                    Sleepy TV detected: {{ kodi_now_playing }}. Skipping media conversation.

        default:
          # --- Media offer (conditional) ---
          - alias: "Bedtime media offer — skip entirely if feature is disabled"
            choose:
              - alias: "Media offer enabled — proceed with mode-specific flow"
                conditions:
                  - condition: template
                    value_template: "{{ enable_media }}"
                sequence:
                  # =========================================================
                  # JSON-RPC LIBRARY PRE-FETCH ENGINE
                  # =========================================================
                  - alias: "Library pre-fetch — conditional on fetch enabled and mode needs it"
                    choose:
                      - alias: "Library fetch enabled and mode requires it (freeform or both)"
                        conditions:
                          - condition: template
                            value_template: >-
                              {{ library_fetch_enabled
                                 and bedtime_media_mode in ['freeform', 'both'] }}
                        sequence:
                          # --- Call 1: In-Progress TV Shows ---
                          - alias: "Pre-fetch: get in-progress TV shows"
                            continue_on_error: true
                            action: kodi.call_method
                            target:
                              entity_id: !input kodi_entity
                            data:
                              method: VideoLibrary.GetInProgressTVShows
                              properties:
                                - title
                                - episode
                                - watchedepisodes
                                - lastplayed
                                - genre
                              limits:
                                start: 0
                                end: "{{ shows_limit | int(20) }}"
                              sort:
                                method: lastplayed
                                order: descending

                          - alias: "Pre-fetch: wait for in-progress TV shows result"
                            wait_for_trigger:
                              - trigger: event
                                event_type: kodi_call_method_result
                                event_data:
                                  entity_id: !input kodi_entity
                                  result_ok: true
                            timeout:
                              seconds: "{{ library_fetch_timeout | int(10) }}"
                            continue_on_timeout: true

                          - alias: "Pre-fetch: store in-progress TV shows result"
                            variables:
                              prefetch_inprogress: >-
                                {{ wait.trigger.event.data.result | default({}) if wait.trigger is defined else {} }}

                          # --- Call 2: Movies ---
                          - alias: "Pre-fetch: get movies"
                            continue_on_error: true
                            action: kodi.call_method
                            target:
                              entity_id: !input kodi_entity
                            data:
                              method: VideoLibrary.GetMovies
                              properties:
                                - title
                                - genre
                                - year
                                - file
                                - runtime
                                - playcount
                              limits:
                                start: 0
                                end: "{{ movies_limit | int(50) }}"
                              sort:
                                method: title
                                order: ascending
                                ignorearticle: true

                          - alias: "Pre-fetch: wait for movies result"
                            wait_for_trigger:
                              - trigger: event
                                event_type: kodi_call_method_result
                                event_data:
                                  entity_id: !input kodi_entity
                                  result_ok: true
                            timeout:
                              seconds: "{{ library_fetch_timeout | int(10) }}"
                            continue_on_timeout: true

                          - alias: "Pre-fetch: store movies result"
                            variables:
                              prefetch_movies: >-
                                {{ wait.trigger.event.data.result | default({}) if wait.trigger is defined else {} }}

                          # --- Call 3: Recently Added Episodes ---
                          - alias: "Pre-fetch: get recently added episodes"
                            continue_on_error: true
                            action: kodi.call_method
                            target:
                              entity_id: !input kodi_entity
                            data:
                              method: VideoLibrary.GetRecentlyAddedEpisodes
                              properties:
                                - title
                                - showtitle
                                - season
                                - episode
                                - file
                                - firstaired
                                - playcount
                              limits:
                                start: 0
                                end: "{{ recent_limit | int(20) }}"

                          - alias: "Pre-fetch: wait for recently added episodes result"
                            wait_for_trigger:
                              - trigger: event
                                event_type: kodi_call_method_result
                                event_data:
                                  entity_id: !input kodi_entity
                                  result_ok: true
                            timeout:
                              seconds: "{{ library_fetch_timeout | int(10) }}"
                            continue_on_timeout: true

                          - alias: "Pre-fetch: store recently added episodes result"
                            variables:
                              prefetch_recent: >-
                                {{ wait.trigger.event.data.result | default({}) if wait.trigger is defined else {} }}

                          # --- Call 4: Favourites ---
                          - alias: "Pre-fetch: get favourites"
                            continue_on_error: true
                            action: kodi.call_method
                            target:
                              entity_id: !input kodi_entity
                            data:
                              method: Favourites.GetFavourites
                              properties:
                                - path
                                - thumbnail
                                - window
                                - windowparameter

                          - alias: "Pre-fetch: wait for favourites result"
                            wait_for_trigger:
                              - trigger: event
                                event_type: kodi_call_method_result
                                event_data:
                                  entity_id: !input kodi_entity
                                  result_ok: true
                            timeout:
                              seconds: "{{ library_fetch_timeout | int(10) }}"
                            continue_on_timeout: true

                          - alias: "Pre-fetch: store favourites result"
                            variables:
                              prefetch_favourites: >-
                                {{ wait.trigger.event.data.result | default({}) if wait.trigger is defined else {} }}

                  # =========================================================
                  # BUILD CATALOG STRING FOR LLM CONTEXT
                  # =========================================================
                  - alias: "Build Kodi catalog string — genre-filtered, structured for LLM injection"
                    variables:
                      kodi_catalog: >-
                        {% set excluded = kodi_excluded_genres.split(',') | map('trim') | map('lower') | reject('eq', '') | list %}
                        {% set preferred = kodi_preferred_genres.split(',') | map('trim') | map('lower') | reject('eq', '') | list %}

                        {# ---- Curated content (if curated or both mode) ---- #}
                        {% set ns_curated = namespace(items=[]) %}
                        {% if bedtime_media_mode in ['curated', 'both'] and kodi_curated_text | default('') | length > 0 %}
                          {% set lines = kodi_curated_text.split('\n') | reject('eq', '') | list %}
                          {% for line in lines %}
                            {% set parts = line.split('=', 1) %}
                            {% if parts | length == 2 %}
                              {% set ns_curated.items = ns_curated.items + [{'name': parts[0] | trim, 'content_id': parts[1] | trim}] %}
                            {% endif %}
                          {% endfor %}
                        {% endif %}
                        {% set curated_items = ns_curated.items %}

                        {# ---- In-progress TV shows (NO genre filtering) ---- #}
                        {% set in_progress = prefetch_inprogress.tvshows | default([]) if prefetch_inprogress is defined else [] %}

                        {# ---- Movies (genre filtered) ---- #}
                        {% set all_movies = prefetch_movies.movies | default([]) if prefetch_movies is defined else [] %}
                        {% set ns_movies = namespace(items=[]) %}
                        {% for m in all_movies %}
                          {% set movie_genres = m.genre | default([]) | map('lower') | list %}
                          {% set dominated = movie_genres | select('in', excluded) | list %}
                          {% if not dominated %}
                            {% set ns_movies.items = ns_movies.items + [m] %}
                          {% endif %}
                        {% endfor %}
                        {% set movies = ns_movies.items %}

                        {# ---- Recent episodes ---- #}
                        {% set recent_eps = prefetch_recent.episodes | default([]) if prefetch_recent is defined else [] %}

                        {# ---- Favourites ---- #}
                        {% set favourites = prefetch_favourites.favourites | default([]) if prefetch_favourites is defined else [] %}

                        === KODI LIBRARY CATALOG ===

                        {% if curated_items %}
                        CURATED BEDTIME OPTIONS (offer these first in curated/both modes):
                        {% for item in curated_items %}
                        {{ loop.index }}. {{ item.name }} [content_id: {{ item.content_id }}]
                        {% endfor %}
                        {% endif %}

                        {% if in_progress %}
                        IN-PROGRESS TV SHOWS (currently watching — always offer continuations):
                        {% for s in in_progress %}
                        - "{{ s.title }}" — {{ s.watchedepisodes }}/{{ s.episode }} eps watched, last played {{ s.lastplayed | default('unknown') }}, genres: {{ s.genre | default([]) | join(', ') }}
                        {% endfor %}
                        {% endif %}

                        {% if movies %}
                        MOVIES IN LIBRARY ({{ movies | length }} titles{% if excluded %}, excluded genres: {{ excluded | join(', ') }}{% endif %}):
                        {% for m in movies %}
                        - "{{ m.title }}" ({{ m.year | default('?') }}) — {{ m.runtime | default('?') }}min, genres: {{ m.genre | default([]) | join(', ') }}, {{ 'watched' if m.playcount | default(0) | int > 0 else 'unwatched' }} [file: {{ m.file | default('') }}]
                        {% endfor %}
                        {% endif %}

                        {% if recent_eps %}
                        RECENTLY ADDED EPISODES:
                        {% for e in recent_eps %}
                        - "{{ e.showtitle | default('') }}" S{{ '%02d' | format(e.season | default(0) | int) }}E{{ '%02d' | format(e.episode | default(0) | int) }} "{{ e.title | default('') }}" — aired {{ e.firstaired | default('?') }}, {{ 'watched' if e.playcount | default(0) | int > 0 else 'unwatched' }} [file: {{ e.file | default('') }}]
                        {% endfor %}
                        {% endif %}

                        {% if favourites %}
                        FAVOURITES:
                        {% for f in favourites %}
                        {% if f.type | default('') == 'media' %}
                        - "{{ f.title | default('') }}" ({{ f.type | default('') }}) [path: {{ f.path | default('N/A') }}]
                        {% endif %}
                        {% endfor %}
                        {% endif %}

                        === SELECTION INSTRUCTIONS ===
                        User mood: {{ kodi_bedtime_mood }}
                        {% if preferred %}Preferred genres: {{ preferred | join(', ') }}{% endif %}
                        {% if excluded %}NEVER suggest: {{ excluded | join(', ') }}{% endif %}
                        Prioritize in-progress shows (offer to continue watching).
                        For movies, prefer unwatched content matching the mood.
                        When you've selected content, call the play_bedtime_kodi function with the content details.

                  # =========================================================
                  # BUILD MODE-SPECIFIC MEDIA PROMPT
                  # =========================================================
                  - alias: "Build media selection prompt based on mode"
                    variables:
                      media_prompt: >-
                        {% if bedtime_media_mode == 'curated' %}
                          Ask if they want bedtime content on the TV. Offer ONLY the curated options
                          from the catalog above. If they decline, say okay. If they pick one, call
                          the play_bedtime_kodi function with content_type "favourite" and the content_id
                          from the catalog. If they want none, that's fine.
                        {% elif bedtime_media_mode == 'freeform' %}
                          Ask if they want bedtime content on the TV. They can request anything from
                          the library catalog above — a specific movie, continue a TV show, or pick
                          a favourite. Use the play_bedtime_kodi function with the appropriate
                          content_type and content_id from the catalog.
                        {% else %}
                          Ask if they want bedtime content on the TV. Offer the curated favorites first,
                          but also mention they can pick from their library. Use the play_bedtime_kodi
                          function with the appropriate content_type and content_id from the catalog.
                        {% endif %}

                  # =========================================================
                  # START SATELLITE CONVERSATION
                  # =========================================================
                  - alias: "Pause before media conversation — let satellite fully settle"
                    delay:
                      seconds: 3

                  - alias: "Start media selection conversation — agent uses tool script for playback"
                    continue_on_error: true
                    action: assist_satellite.start_conversation
                    target: !input assist_satellites
                    data:
                      preannounce: true
                      start_message: >-
                        {% if bedtime_media_mode == 'curated' %}
                          Want something on the TV for bedtime? I've got your usual options ready.
                        {% elif bedtime_media_mode == 'freeform' %}
                          Want something on the TV for bedtime? I've got your whole library to pick from.
                        {% else %}
                          Want something on the TV for bedtime? I've got your favorites — or anything from the library.
                        {% endif %}
                      extra_system_prompt: >-
                        {{ media_prompt }}

                        Kodi entity: {{ kodi_entity }}
                        Kodi is currently playing: {{ kodi_now_playing }}.

                        {{ kodi_catalog }}

                  - alias: "Wait for media conversation to settle — satellite needs time for the full exchange"
                    delay:
                      seconds: 30

                  # --- Post-conversation settling-in TTS ---
                  - alias: "Settling-in TTS — optional contextual announcement after content starts"
                    choose:
                      - alias: "Settling-in TTS is enabled — generate and deliver"
                        conditions:
                          - condition: template
                            value_template: "{{ enable_settling }}"
                        sequence:
                          - alias: "Build sensor context string for settling-in prompt"
                            variables:
                              settling_sensor_context: >-
                                {% set ns = namespace(lines=[]) %}
                                {% for eid in settling_sensor_list %}
                                  {% set ns.lines = ns.lines + [eid ~ ': ' ~ (states(eid) | default('unknown'))] %}
                                {% endfor %}
                                {{ ns.lines | join('\n') }}

                          - alias: "Generate settling-in message via conversation agent"
                            continue_on_error: true
                            action: conversation.process
                            response_variable: settling_response
                            data:
                              agent_id: "{{ conversation_agent }}"
                              text: >-
                                {{ settling_prompt_tpl }}

                                Kodi is currently playing: {{ kodi_now_playing }}.

                                Current sensor readings:
                                {{ settling_sensor_context }}

                          - alias: "Extract settling-in message with defensive fallback"
                            variables:
                              settling_message: >-
                                {% if settling_response is defined
                                   and settling_response.response is defined
                                   and settling_response.response.response_type | default('') != 'error'
                                   and settling_response.response.speech is defined %}
                                  {{ settling_response.response.speech.plain.speech
                                     | default('') }}
                                {% else %}
                                  {{ '' }}
                                {% endif %}

                          - alias: "Deliver settling-in TTS if agent produced a message"
                            choose:
                              - alias: "Agent returned a non-empty settling message — speak it"
                                conditions:
                                  - condition: template
                                    value_template: "{{ settling_message | default('') | trim | length > 0 }}"
                                sequence:
                                  - alias: "Speak settling-in message via TTS"
                                    choose:
                                      - alias: "TTS with voice profile (ElevenLabs)"
                                        conditions:
                                          - condition: template
                                            value_template: "{{ voice_profile_val | default('') | string | length > 0 }}"
                                        sequence:
                                          - alias: "Speak settling-in with custom voice profile"
                                            continue_on_error: true
                                            action: tts.speak
                                            target:
                                              entity_id: "{{ tts_engine_entity }}"
                                            data:
                                              media_player_entity_id: "{{ kodi_tts_player }}"
                                              message: "{{ settling_message }}"
                                              options:
                                                voice_profile: "{{ voice_profile_val }}"
                                    default:
                                      - alias: "Speak settling-in with default TTS voice"
                                        continue_on_error: true
                                        action: tts.speak
                                        target:
                                          entity_id: "{{ tts_engine_entity }}"
                                        data:
                                          media_player_entity_id: "{{ kodi_tts_player }}"
                                          message: "{{ settling_message }}"

                                  - alias: "Post-TTS buffer for settling-in message"
                                    delay:
                                      seconds: "{{ post_tts_delay_val }}"

      # --- Goodnight message (conversational modes only) ---
      - alias: "Generate goodnight message via conversation agent"
        continue_on_error: true
        action: conversation.process
        response_variable: goodnight_response
        data:
          agent_id: "{{ conversation_agent }}"
          text: "{{ goodnight_prompt_tpl }}"

      - alias: "Extract goodnight message with defensive fallback"
        variables:
          goodnight_message: >-
            {% if goodnight_response is defined
               and goodnight_response.response is defined
               and goodnight_response.response.response_type | default('') != 'error'
               and goodnight_response.response.speech is defined %}
              {{ goodnight_response.response.speech.plain.speech
                 | default("Goodnight. Sleep well.") }}
            {% else %}
              Goodnight. Sleep well.
            {% endif %}

      - alias: "Deliver goodnight via TTS"
        choose:
          - alias: "TTS with voice profile (ElevenLabs)"
            conditions:
              - condition: template
                value_template: "{{ voice_profile_val | default('') | string | length > 0 }}"
            sequence:
              - alias: "Speak goodnight message with custom voice profile"
                continue_on_error: true
                action: tts.speak
                target:
                  entity_id: "{{ tts_engine_entity }}"
                data:
                  media_player_entity_id: "{{ kodi_tts_player }}"
                  message: "{{ goodnight_message }}"
                  options:
                    voice_profile: "{{ voice_profile_val }}"
        default:
          - alias: "Speak goodnight message with default TTS voice"
            continue_on_error: true
            action: tts.speak
            target:
              entity_id: "{{ tts_engine_entity }}"
            data:
              media_player_entity_id: "{{ kodi_tts_player }}"
              message: "{{ goodnight_message }}"

      - alias: "Post-TTS buffer — let goodnight finish playing"
        delay:
          seconds: "{{ post_tts_delay_val }}"

      # --- Countdown — wait the negotiated duration ---
      - alias: "Wait the negotiated countdown — lamp stays on, user goes to bed"
        delay:
          minutes: "{{ final_countdown | int(default_countdown) }}"

      # --- Bathroom guard (conversational modes) ---
      - alias: "Bathroom guard — check occupancy if sensor configured"
        choose:
          - alias: "No bathroom sensor configured — skip guard entirely"
            conditions:
              - condition: template
                value_template: "{{ (bathroom_sensor | default('')) | length == 0 }}"
            sequence: []
          - alias: "Bathroom occupied — wait for it to clear before turning off lamp"
            conditions:
              - condition: state
                entity_id: !input bathroom_sensor
                state: "on"
            sequence:
              - alias: "Wait for bathroom sensor to clear — max timeout prevents infinite wait"
                wait_for_trigger:
                  - trigger: state
                    entity_id: !input bathroom_sensor
                    to: "off"
                timeout: !input bathroom_max_timeout
                continue_on_timeout: true

              - alias: "Handle bathroom guard timeout — lights off regardless, can't wait forever"
                if:
                  - condition: template
                    value_template: "{{ not (wait.completed | default(false)) }}"
                then:
                  - alias: "Bathroom guard timed out — proceeding with lamp off anyway"
                    continue_on_error: true
                    action: logbook.log
                    data:
                      name: "Bedtime Routine Plus"
                      message: >-
                        Bathroom guard timed out after max wait. Turning off lamp regardless.
                else:
                  - alias: "Bathroom cleared — grace period before turning off lamp"
                    delay: !input bathroom_grace_period

        default:
          - alias: "Bathroom not occupied — check it's been clear long enough"
            choose:
              - alias: "Bathroom was recently occupied — enforce grace period"
                conditions:
                  - condition: state
                    entity_id: !input bathroom_sensor
                    state: "off"
                    for: !input bathroom_grace_period
                sequence:
                  - alias: "Grace period already satisfied — proceed to lamp off"
                    continue_on_error: true
                    action: logbook.log
                    data:
                      name: "Bedtime Routine Plus"
                      message: "Bathroom clear and grace period satisfied. Turning off lamp."
            default:
              - alias: "Bathroom recently cleared — wait full grace period as safety margin"
                delay: !input bathroom_grace_period

      # --- Optional final goodnight contextual TTS (conversational modes) ---
      - alias: "Final goodnight context TTS — optional contextual announcement after bathroom clears"
        choose:
          - alias: "Final goodnight TTS is enabled — generate and deliver"
            conditions:
              - condition: template
                value_template: "{{ enable_gn_context }}"
            sequence:
              - alias: "Build sensor context string for goodnight prompt"
                variables:
                  gn_sensor_context: >-
                    {% set ns = namespace(lines=[]) %}
                    {% for eid in gn_sensor_list %}
                      {% set ns.lines = ns.lines + [eid ~ ': ' ~ (states(eid) | default('unknown'))] %}
                    {% endfor %}
                    {{ ns.lines | join('\n') }}

              - alias: "Generate final goodnight via conversation agent with sensor context"
                continue_on_error: true
                action: conversation.process
                response_variable: gn_context_response_conv
                data:
                  agent_id: "{{ conversation_agent }}"
                  text: >-
                    {{ gn_context_prompt_tpl }}

                    Kodi is playing: {{ kodi_now_playing }}.

                    Current sensor readings:
                    {{ gn_sensor_context }}

              - alias: "Extract goodnight context message with defensive fallback"
                variables:
                  gn_context_message_conv: >-
                    {% if gn_context_response_conv is defined
                       and gn_context_response_conv.response is defined
                       and gn_context_response_conv.response.response_type | default('') != 'error'
                       and gn_context_response_conv.response.speech is defined %}
                      {{ gn_context_response_conv.response.speech.plain.speech
                         | default('Goodnight. Sleep well.') }}
                    {% else %}
                      Goodnight. Sleep well.
                    {% endif %}

              - alias: "Deliver final goodnight via TTS"
                choose:
                  - alias: "TTS with voice profile (ElevenLabs)"
                    conditions:
                      - condition: template
                        value_template: "{{ voice_profile_val | default('') | string | length > 0 }}"
                    sequence:
                      - alias: "Speak goodnight with custom voice profile"
                        continue_on_error: true
                        action: tts.speak
                        target:
                          entity_id: "{{ tts_engine_entity }}"
                        data:
                          media_player_entity_id: "{{ kodi_tts_player }}"
                          message: "{{ gn_context_message_conv }}"
                          options:
                            voice_profile: "{{ voice_profile_val }}"
                default:
                  - alias: "Speak goodnight with default TTS voice"
                    continue_on_error: true
                    action: tts.speak
                    target:
                      entity_id: "{{ tts_engine_entity }}"
                    data:
                      media_player_entity_id: "{{ kodi_tts_player }}"
                      message: "{{ gn_context_message_conv }}"

              - alias: "Post-TTS buffer for final goodnight"
                delay:
                  seconds: "{{ post_tts_delay_val }}"

  # --- Common tail (both modes) — lamp off + cleanup ----------------------------

  - alias: "Lights out — turn off the living room lamp"
    continue_on_error: true
    action: homeassistant.turn_off
    target:
      entity_id: "{{ living_room_lamp }}"

  - alias: "Cleanup — turn off temporary switches"
    continue_on_error: true
    action: homeassistant.turn_off
    target: !input temporary_switches

  - alias: "Reset countdown helper to default for next run"
    continue_on_error: true
    action: input_number.set_value
    target:
      entity_id: !input countdown_helper
    data:
      value: "{{ default_countdown }}"

  # --- TV Sleep Timer (fires after main routine cleanup) ----------------------

  - alias: "TV sleep timer: check if enabled"
    if:
      - condition: template
        value_template: "{{ sleep_timer_enabled }}"
    then:
      - alias: "TV sleep timer: wait configured minutes"
        delay:
          minutes: "{{ sleep_timer_minutes | int(60) }}"

      - alias: "TV sleep timer: power off TV via configured method"
        choose:
          - alias: "TV sleep timer: CEC standby"
            conditions:
              - condition: template
                value_template: "{{ sleep_timer_method == 'cec' }}"
            sequence:
              - alias: "TV sleep timer: send CEC power-off via media_player.turn_off"
                action: media_player.turn_off
                target:
                  entity_id: "{{ tv_entity }}"
                continue_on_error: true
          - alias: "TV sleep timer: custom script"
            conditions:
              - condition: template
                value_template: "{{ sleep_timer_method == 'script' }}"
            sequence:
              - alias: "TV sleep timer: fire custom TV off script"
                action: script.turn_on
                target:
                  entity_id: "{{ tv_off_script }}"
                continue_on_error: true

# ═══════════════════════════════════════════════════════════════════════
# Mode — single, no overlapping bedtime runs
# ═══════════════════════════════════════════════════════════════════════
mode: single
max_exceeded: silent

trace:
  stored_traces: 15
